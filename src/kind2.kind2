// Kind2 implemented in Kind2
// ==========================

// U32
// ===

(U32.if a:Type cond:U32 if_t:a if_f:a): a
  (U32.if a 0 t f) = f
  (U32.if a 1 t f) = t

(U32.and a:U32 b:U32): U32
  (U32.and 0 b) = 0
  (U32.and 1 b) = b

(U32.not a:U32): U32
  (U32.not 0) = 1
  (U32.not 1) = 0

(U32.read str:String) : U32
  (U32.read str) = (U32.read.go str 0)

(U32.read.go str:String r:U32) : U32
  (U32.read.go String.nil         r) = r
  (U32.read.go (String.cons x xs) r) = (U32.if U32 (& (<= '0' x) (<= x '9')) (U32.read.go xs (+ (* r 10) (- x '0'))) 0) 

// TODO: parser error huh...
(U32.show n:U32) : String
  // (U32.show n) = (U32.show_build n String.nil)
(U32.show_build n:U32 str:String) : String
  // (U32.show_build n str) = 
    // let next = (String.cons (+ 48 (% n 10)) str)
    // ((U32.if String (< n 10) λx(x) λx(U32.show_build (/ n 10) x)) next)

// Unit
// ====

Unit: Type
  Unit.new : Unit

// Bool
// ====

Bool: Type
  Bool.true  : Bool
  Bool.false : Bool

(Bool.if a:Type Bool if_t:a if_f:a): a
  (Bool.if a Bool.false t f) = f
  (Bool.if a Bool.true  t f) = t

// Pair
// ====

(Pair a:Type b:Type): Type
  (Pair.new a:Type b:Type fst:a snd:b): (Pair a b)

(Pair.get a:Type b:Type c:Type p:(Pair a b) f:∀(x:a)∀(y:b)c): c
  (Pair.get a b c (Pair.new a b x y) f) = (f x y)

(Pair.fst a:Type b:Type p:(Pair a b)): a
  (Pair.fst a b (Pair.new a b x y)) = x

(Pair.snd a:Type b:Type p:(Pair a b)): b
  (Pair.snd a b (Pair.new a b x y)) = y

(Pair.fst.mut a:Type b:Type p:(Pair a b) f:∀(x:a)a): (Pair a b)
  (Pair.fst.mut a b (Pair.new a b x y) f) = (Pair.new a b (f x) y)

(Pair.snd.mut a:Type b:Type p:(Pair a b) f:∀(x:b)b): (Pair a b)
  (Pair.snd.mut a b (Pair.new a b x y) f) = (Pair.new a b x (f y))


// Triple
// ======

(Triple a:Type b:Type c:Type): Type
  (Triple.new a:Type b:Type c:Type fst:a snd:b trd:c): (Triple a b c)

(Triple.get a:Type b:Type c:Type d:Type t:(Triple a b c) f:∀(x:a)∀(y:b)∀(z:c)d): d
  (Triple.get a b c d (Triple.new a b c x y z) f) = (f x y z)

// Tuple2
// ======

(Tuple2 a:Type b:Type): Type
  (Tuple2 a b) = ∀(p: Type) ∀(new: ∀(x0: a) ∀(x1: b) p) p

(Tuple2.new a:Type b:Type x0:a x1:b): (Tuple2 a b)
  (Tuple2.new a b x0 x1) = λp λnew (new x0 x1)

(Tuple2.get a:Type b:Type c:Type p:(Tuple2 a b) f:∀(x:a)∀(y:b)c): c
  (Tuple2.get a b c tup f) = (tup c f)

// Maybe
// =====

(Maybe a:Type): Type
  (Maybe.none a:Type)     : (Maybe a)
  (Maybe.some a:Type x:a) : (Maybe a)

(Maybe.case a:Type r:Type m:(Maybe a) none:r some:∀(x:a)r): r
  (Maybe.case a r (Maybe.some a x) case_none case_some) = (case_some x)
  (Maybe.case a r (Maybe.none a)   case_none case_some) = case_none

// List
// ====

(List a:Type): Type
  (List.nil a:Type)                       : (List a)
  (List.cons a:Type head:a tail:(List a)) : (List a)

(List.map a:Type b:Type l:(List a) f:∀(x:a)b): (List b)
  (List.map a b (List.nil a) f)            = (List.nil b)
  (List.map a b (List.cons a head tail) f) = (List.cons b (f head) (List.map a b tail f))

(List.reverse a:Type l:(List a)): (List a)
  (List.reverse a l) = (List.reverse.go a l (List.nil a))

(List.reverse.go a:Type l:(List a) r:(List a)): (List a)
  (List.reverse.go a (List.nil a)            r) = r
  (List.reverse.go a (List.cons a head tail) r) = (List.reverse.go a tail (List.cons a head r))

(List.length a:Type l:(List a)): U32
  (List.length a (List.nil a))            = 0
  (List.length a (List.cons a head tail)) = (+ 1 (List.length a tail))

(List.is_empty a:Type l:(List a)): U32
  (List.is_empty a (List.nil a))            = 1
  (List.is_empty a (List.cons a head tail)) = 0

(List.concat a:Type xs:(List a) ys:(List a)): (List a)
  (List.concat a (List.nil a)       ys) = ys
  (List.concat a (List.cons a x xs) ys) = (List.cons a x (List.concat a xs ys))

(List.fold a:Type r:Type xs:(List a) nil:r cons:∀(x:a)∀(xs:r)r): r
  (List.fold a r (List.nil a)       nil cons) = nil
  (List.fold a r (List.cons a x xs) nil cons) = (cons x (List.fold a r xs nil cons))

(List.to_map a:Type list:(List (Pair U32 a))) : (Map a)
  (List.to_map a list) = (List.to_map.go a list (Map.empty a))

(List.to_map.go a:Type list:(List (Pair U32 a)) map:(Map a)) : (Map a)
  (List.to_map.go a (List.nil (Pair U32 a))                              map) = map
  (List.to_map.go a (List.cons (Pair U32 a) (Pair.new U32 a key val) xs) map) = (List.to_map.go a xs (Map.set a map key val))

// Name
// ====

Name : Type
  (Name.new str:String hash:U32) : Name

(Name.make str:String) : Name
  (Name.make str) = (Name.new str (String.hash str))

(Name.get_hash name:Name) : U32
  (Name.get_hash (Name.new str hash)) = hash

(Name.get_string name:Name) : String
  (Name.get_string (Name.new str hash)) = str
  (Name.get_string (Name.new str hash)) = (String.concat "TODO: Name.get_string" str)

(Name.equal a_name:Name b_name:Name) : U32
  (Name.equal (Name.new a_str a_hash) (Name.new b_str b_hash)) = (== a_hash b_hash)

// String
// ======

Char : Type
  Char = U32

String : Type
  (String.cons head:Char tail:String) : String
  (String.nil): String

// Returns true if a string is empty
(String.is_empty s:String): Bool
  (String.is_empty String.nil)         = Bool.true
  (String.is_empty (String.cons x xs)) = Bool.false

// Concatenates two strings
(String.concat a:String b:String) : String
  (String.concat String.nil         ys) = ys
  (String.concat (String.cons x xs) ys) = (String.cons x (String.concat xs ys))

// Concatenates a list of strings
(String.flatten a:(List String)) : String
  (String.flatten (List.nil a))            = String.nil
  (String.flatten (List.cons String x xs)) = (String.concat x (String.flatten xs))

// Returns true if two strings are equal
(String.equal xs:String ys:String) : U32
  (String.equal String.nil         String.nil)         = 1
  (String.equal (String.cons x xs) (String.cons y ys)) = (& (== x y) (String.equal xs ys))
  (String.equal xs             ys)             = 0

(String.hash xs:String) : U32
  (String.hash str) = (String.hash.go str 0)

(String.hash.go xs:String hash:U32) : U32
  (String.hash.go String.nil         hash) = hash
  (String.hash.go (String.cons x xs) hash) = (String.hash.go xs (+ (- (<< hash 5) hash) x))

(String.map xs:String f:∀(x:Char)Char) : String
  (String.map String.nil         f) = String.nil
  (String.map (String.cons x xs) f) = (String.cons (f x) (String.map xs f))

(String.join xs:(List String) sep:String) : String
  (String.join (List.nil String)                       sep) = String.nil
  (String.join (List.cons String x (List.nil String))  sep) = x
  (String.join (List.cons String x xs)                 sep) = (String.flatten (List.cons String x (List.cons String (String.join xs sep) (List.nil String))))

// Map
// ===

(Map a:Type) : Type
  (Map.empty a:Type)                         : (Map a)
  (Map.entry a:Type value:a)                 : (Map a)
  (Map.nodes a:Type lft:(Map a) rgt:(Map a)) : (Map a)

(Map.length a:Type tree:(Map a)) : U32
  (Map.length a (Map.empty a        )) = 0
  (Map.length a (Map.entry a     val)) = 1
  (Map.length a (Map.nodes a lft rgt)) = (+ (Map.length a lft) (Map.length a rgt))

(Map.get a:Type tree:(Map a) key:U32) : (Pair (Map a) (Maybe a))
(Map.get a tree key) = (Map.get.go a 32 tree key (λx x))

(Map.get.go a:Type n:U32 tree:(Map a) key:U32 self:∀(x:(Map a))(Map a)) : (Pair (Map a) (Maybe a))
  (Map.get.go a n (Map.empty a) key self) =
    (Pair.new (Map a) (Maybe a) (self (Map.empty a)) (Maybe.none a))
  (Map.get.go a n (Map.entry a val) key self) =
    (Pair.new (Map a) (Maybe a) (self (Map.entry a val)) (Maybe.some a val))
  (Map.get.go a n (Map.nodes a lft rgt) key self) =
    (Map.get.go.nodes a (& (>> key (- n 1)) 1) (- n 1) key lft rgt self)

(Map.get.go.nodes a:Type i:U32 n:U32 key:U32 lft:(Map a) rgt:(Map a) self:∀(x:(Map a))(Map a)) : (Pair (Map a) (Maybe a))
  (Map.get.go.nodes a 0 n key lft rgt self) =
    (Map.get.go a n lft key λx(self (Map.nodes a x rgt)))
  (Map.get.go.nodes a 1 n key lft rgt self) =
    (Map.get.go a n rgt key λx(self (Map.nodes a lft x)))

(Map.delete a:Type tree:(Map a) key:U32) : (Map a)
(Map.delete a tree key) = (Map.delete.go a 32 tree key)

(Map.delete.go a:Type n:U32 tree:(Map a) key:U32) : (Map a)
  (Map.delete.go a n (Map.nodes a lft rgt) key) =
    (Map.delete.go.nodes a (& (>> key (- n 1)) 1) (- n 1) lft rgt key)
  (Map.delete.go a n tree key) = (Map.empty a)

(Map.delete.go.nodes a:Type i:U32 n:U32 lft:(Map a) rgt:(Map a) key:U32) : (Map a)
  (Map.delete.go.nodes a 0 n lft rgt key) =
    (Map.nodes a (Map.delete.go a n lft key) rgt)
  (Map.delete.go.nodes a 1 n lft rgt key) =
    (Map.nodes a lft (Map.delete.go a n rgt key))

(Map.set a:Type tree:(Map a) key:U32 val:a) : (Map a)
(Map.set a tree key val) = (Map.set.go a 32 tree key val)

(Map.set.go a:Type n:U32 tree:(Map a) key:U32 val:a) : (Map a)
  (Map.set.go a 0 tree          key val) = (Map.entry a val)
  (Map.set.go a n (Map.empty a) key val) =
    (Map.set.go.empty a (& (>> key (- n 1)) 1) (- n 1) key val)
  (Map.set.go a n (Map.nodes a lft rgt) key val) =
    (Map.empty a)

(Map.set.go.empty a:Type i:U32 n:U32 key:U32 val:a) : (Map a)
  (Map.set.go.empty a 0 n key val) =
    (Map.nodes a (Map.set.go a n (Map.empty a) key val) (Map.empty a))
  (Map.set.go.empty a 1 n key val) =
    (Map.nodes a (Map.empty a) (Map.set.go a n (Map.empty a) key val))

(Map.set.go.nodes a:Type i:U32 n:U32 key:U32 lft:(Map a) rgt:(Map a) val:a) : (Map a)
  (Map.set.go.nodes a 0 n key lft rgt val) =
    (Map.nodes a (Map.set.go a n lft key val) rgt)
  (Map.set.go.nodes a 1 n key lft rgt val) =
    (Map.nodes a lft (Map.set.go a n rgt key val))

(Map.mut a:Type tree:(Map a) key:U32 f:∀(v:a)a) : (Map a)
(Map.mut a tree key f) = (Map.mut.go a 32 tree key f)

(Map.mut.go a:Type n:U32 tree:(Map a) key:U32 f:∀(v:a)a) : (Map a)
  (Map.mut.go a 0 (Map.entry a x) key f) = (Map.entry a (f x))
  (Map.mut.go a 0 tree            key f) = tree
  (Map.mut.go a n (Map.empty a)   key f) =
    (Map.mut.go.empty a (& (>> key (- n 1)) 1) (- n 1) key f)
  (Map.mut.go a n (Map.nodes a lft rgt) key f) =
    (Map.mut.go.nodes a (& (>> key (- n 1)) 1) (- n 1) key lft rgt f)

(Map.mut.go.empty a:Type i:U32 n:U32 key:U32 f:∀(v:a)a) : (Map a)
  (Map.mut.go.empty a 0 n key f) =
    (Map.nodes a (Map.mut.go a n (Map.empty a) key f) (Map.empty a))
  (Map.mut.go.empty a 1 n key f) =
    (Map.nodes a (Map.empty a) (Map.mut.go a n (Map.empty a) key f))

(Map.mut.go.nodes a:Type i:U32 n:U32 key:U32 lft:(Map a) rgt:(Map a) f:∀(v:a)a) : (Map a)
  (Map.mut.go.nodes a 0 n key lft rgt f) =
    (Map.nodes a (Map.mut.go a n lft key f) rgt)
  (Map.mut.go.nodes a 1 n key lft rgt f) =
    (Map.nodes a lft (Map.mut.go a n rgt key f))

(Map.to_list a:Type val:(Map a)) : (List (Pair U32 a))
  (Map.to_list a val) = ((Map.to_list.go a val 0) (List.nil (Pair U32 a)))

(Map.to_list.go a:Type val:(Map a) key:U32) : ∀(x:(List (Pair U32 a)))(List (Pair U32 a))
  (Map.to_list.go a (Map.empty a)     key) = λx x
  (Map.to_list.go a (Map.entry a val) key) = λx
    (List.cons (Pair U32 a) (Pair.new U32 a key val) x)
  (Map.to_list.go a (Map.nodes a lft rgt) key) = λx
    ((Map.to_list.go a lft (* key 2)) ((Map.to_list.go a rgt (+ (* key 2) 1)) x))

(Map.values a:Type val:(Map a)) : (List a)
  (Map.values a val) = ((Map.values.go a val) (List.nil a))

(Map.values.go a:Type val:(Map a)) : ∀(x:(List a))(List a)
  (Map.values.go a (Map.empty a)        ) = λx x
  (Map.values.go a (Map.entry a val    )) = λx (List.cons a val x)
  (Map.values.go a (Map.nodes a lft rgt)) = λx ((Map.values.go a lft) ((Map.values.go a rgt) x))

// Parser
// ======

Code : Type
  Code = String

(Answer a:Type): Type
  (Answer.parsed a:Type code:(Code) result:a) : (Answer a)
  (Answer.failed a:Type String) : (Answer a)

(Parser a:Type): Type
  (Parser a) = ∀(x: Code) (Answer a)

(Parser.is_name_char chr:Char) : Char
  (Parser.is_name_char chr) = 
  let is_letter = (| (& (<= 'a' chr) (<= chr 'z')) (& (<= 'A' chr) (<= chr 'Z')))
  let is_number = (& (<= '0' chr) (<= chr '9'))
  let is_symbol = (| (== '_' chr) (== '.' chr))
  (| is_letter (| is_number is_symbol))

(Char.is_upper chr:Char) : U32
(Char.is_upper chr) =
  (& (<= 'A' chr) (<= chr 'Z'))

(Char.is_lower chr:Char) : U32
(Char.is_lower chr) =
  (& (<= 'a' chr) (<= chr 'z'))

(Char.is_numeric chr:Char) : U32
(Char.is_numeric chr) =
  (& (<= '0' chr) (<= '9' chr))

(Parser.is_operator chr:Char) : U32
  (Parser.is_operator chr) =
    (| (== '+' chr)
    (| (== '-' chr)
    (| (== '*' chr)
    (| (== '/' chr)
    (| (== '%' chr)
    (| (== '&' chr)
    (| (== '|' chr)
    (| (== '^' chr)
    (| (== '<' chr)
    (| (== '>' chr)
    (| (== '=' chr)
    (| (== '!' chr)
       0))))))))))))

(Parser.bind a:Type b:Type a_parser:(Parser a) f:(∀(x:a)(Parser b))): (Parser b)
  (Parser.bind a b a_parser f) = λcode (Parser.bind.go a b f (a_parser code))

(Parser.bind.go a:Type b:Type f:(∀(x:a)(Parser b)) a_res:(Answer a)) : (Answer b)
  (Parser.bind.go a b f (Answer.parsed a code a_val)) = (f a_val code)
  (Parser.bind.go a b f (Answer.failed a err))        = (Answer.failed b err)

(Parser.done a:Type value:a) : (Parser a)
  (Parser.done a value) = λcode (Answer.parsed a code value)

(Char.is_space chr:Char) : U32
  (Char.is_space chr) = (| (== 10 chr) (== 32 chr))

(Parser.parse_one) : (Parser U32)
  (Parser.parse_one) = λcode (Parser.parse_one.go code)

(Parser.parse_one.go code:String) : (Answer U32)
  (Parser.parse_one.go (String.cons x xs)) = (Answer.parsed U32 xs x)
  (Parser.parse_one.go String.nil)         = (Answer.parsed U32 String.nil 0)

(Parser.get_name) : ∀(code: Code)(Pair String String)
  (Parser.get_name) = λcode (Parser.get_name.go code)

(Parser.get_name.go code:Code) : (Pair String String)
  (Parser.get_name.go String.nil)              = (Pair.new String String String.nil String.nil)
  (Parser.get_name.go (String.cons head tail)) = (Parser.get_name.go_1 (Parser.is_name_char head) head tail)

(Parser.get_name.go_1 cond:U32 head:Char tail:String) : (Pair String String)
  (Parser.get_name.go_1 0 head tail) = (Pair.new String String (String.cons head tail) String.nil)
  (Parser.get_name.go_1 1 head tail) = (Parser.get_name.go_2 head (Parser.get_name.go tail))

(Parser.get_name.go_2 head:Char name_pair:(Pair String String)) : (Pair String String)
  (Parser.get_name.go_2 head (Pair.new Code String code name)) = (Pair.new Code String code (String.cons head name))

(Parser.matcher consume:Bool text:(List (∀(x:Char)U32))) : (Parser Bool)
  (Parser.matcher consume text) = λcode (Parser.matcher.go text code consume λx(x))

(Parser.matcher.go text:(List (∀(x:Char)U32)) code:Code consume:Bool redo:(∀(x:String)Code)) : (Answer Bool)
  (Parser.matcher.go (List.nil  (∀(x:Char)U32))      ys             consume redo) = (Answer.parsed Bool ((Bool.if ∀(x:String)String consume λx(x) redo) ys) Bool.true)
  (Parser.matcher.go (List.cons (∀(x:Char)U32) x xs) String.nil         consume redo) = (Answer.parsed Bool (redo String.nil) Bool.false)
  (Parser.matcher.go (List.cons (∀(x:Char)U32) x xs) (String.cons y ys) consume redo) = (Parser.matcher.go.test (x y) xs y ys consume redo)

(Parser.matcher.go.test cond:U32 xs:(List (∀(x:Char)U32)) y:Char ys:String consume:Bool redo:(∀(x:String)Code)) : (Answer Bool)
  (Parser.matcher.go.test 0 xs y ys consume redo) = (Answer.parsed Bool (redo (String.cons y ys)) Bool.false)
  (Parser.matcher.go.test 1 xs y ys consume redo) = (Parser.matcher.go xs ys consume λk(redo (String.cons y k)))

(Parser.text_comparer str:String) : (List ∀(c:Char)U32)
  (Parser.text_comparer String.nil)         = (List.nil  ∀(c:Char)U32)
  (Parser.text_comparer (String.cons x xs)) = (List.cons ∀(c:Char)U32 λc(== x c) (Parser.text_comparer xs))

(Parser.peek_conds conds:(List (∀(x:Char)U32))) : (Parser Bool)
  (Parser.peek_conds conds) = λcode ((Parser.matcher Bool.false conds) (Parser.skipper code))

(Parser.peek_text text:String) : (Parser Bool)
  (Parser.peek_text text) = λcode ((Parser.matcher Bool.false (Parser.text_comparer text)) (Parser.skipper code))

(Parser.match_conds conds:(List (∀(x:Char)U32))) : (Parser Bool)
  (Parser.match_conds conds) = λcode ((Parser.matcher Bool.true conds) (Parser.skipper code))

(Parser.match_text_here text:String) : (Parser Bool)
  (Parser.match_text_here text) = λcode ((Parser.matcher Bool.true (Parser.text_comparer text)) code)

(Parser.match_text text:String) : (Parser Bool)
  (Parser.match_text text) = λcode ((Parser.matcher Bool.true (Parser.text_comparer text)) (Parser.skipper code))

(Parser.parse_text_here text:String) : (Parser Unit)
  (Parser.parse_text_here text) = (Parser.bind Bool Unit (Parser.match_text_here text) λgot(Parser.text_here_got got))
  (Parser.parse_text_here text) = (Parser.bind Bool Unit (Parser.match_text_here text) λgot(Parser.text_here_got got))

(Parser.text_here_got got:Bool) : (Parser Unit)
  (Parser.text_here_got (Bool.false)) = λcode (Answer.failed Unit "Syntax Error.") 
  (Parser.text_here_got (Bool.true))  = (Parser.done Unit Unit.new)

(Parser.parse_text text:String) : (Parser Unit)
  (Parser.parse_text text) = λcode ((Parser.parse_text_here text) (Parser.skipper code))

// Skips spaces and comments
(Parser.skipper str:String) : String
  (Parser.skipper String.nil)         = String.nil
  (Parser.skipper (String.cons x xs)) = (Parser.skipper.go (Char.is_space x) (== x 47) x xs)

(Parser.skipper.go is_space:U32 is_slash:U32 x:Char xs:String): String
  (Parser.skipper.go 0 0 x xs) = (String.cons x xs)
  (Parser.skipper.go 1 c x xs) = (Parser.skipper xs)
  (Parser.skipper.go s 1 x xs) = (Parser.skipper.drop_comment xs)

(Parser.skipper.drop_comment str:String): String
  (Parser.skipper.drop_comment String.nil)         = String.nil
  (Parser.skipper.drop_comment (String.cons x xs)) = (Parser.skipper.drop_comment.go (== x 10) x xs) 

(Parser.skipper.drop_comment.go is_space:U32 x:Char xs:String): String
  (Parser.skipper.drop_comment.go 1 x xs) = (Parser.skipper xs)
  (Parser.skipper.drop_comment.go 0 x xs) = (Parser.skipper.drop_comment xs)

(Parser.parse_name_here) : (Parser String)
  (Parser.parse_name_here) = λcode (Parser.parse_name_here.go ((Parser.get_name) code))

(Parser.parse_name_here.go name:(Pair Code String)): (Answer String)
  (Parser.parse_name_here.go (Pair.new String String code name)) = (Answer.parsed String code name)

(Parser.parse_name) : (Parser String)
  (Parser.parse_name) = λcode ((Parser.parse_name_here) (Parser.skipper code))

(Parser.parse_end) : (Parser Bool)
  Parser.parse_end = λcode (Parser.parse_end.go code)
(Parser.parse_end.go code:String) : (Answer Bool)
  (Parser.parse_end.go String.nil)         = (Answer.parsed Bool String.nil Bool.true)
  (Parser.parse_end.go (String.cons x xs)) = (Answer.parsed Bool (String.cons x xs) Bool.false)

(Parser.parse_until a:Type stop:(Parser Bool) parser:(Parser a)) : (Parser (List a))
  (Parser.parse_until a stop parser) = (Parser.bind Bool (List a) stop λs (Parser.parse_until.go a s stop parser))

(Parser.parse_until.go a:Type s:Bool stop:(Parser Bool) parser:(Parser a)) : (Parser (List a))
  (Parser.parse_until.go a Bool.false stop parser) =
    (Parser.bind a        (List a) parser                             λhead 
    (Parser.bind (List a) (List a) (Parser.parse_until a stop parser) λtail 
    (Parser.done (List a) (List.cons a head tail))))
  (Parser.parse_until.go a Bool.true stop parser) =
    (Parser.done (List a) (List.nil a))

(Parser.grammar a:Type choices:(List (Parser (Maybe a))))          : (Parser a)
  (Parser.grammar a (List.nil (Parser (Maybe a))))                 = λcode (Answer.failed a "TODO: Parser.grammer empty list")
  (Parser.grammar a (List.cons (Parser (Maybe a)) choice choices)) = λcode (Parser.grammar.go a (choice code) choices)

(Parser.grammar.go a:Type choice_res:(Answer (Maybe a)) choices:(List (Parser (Maybe a)))) : (Answer a)
  (Parser.grammar.go a (Answer.failed a err)                        choices) = (Answer.failed a err)
  (Parser.grammar.go a (Answer.parsed a code (Maybe.none a))        choices) = ((Parser.grammar a choices) code)
  (Parser.grammar.go a (Answer.parsed a code (Maybe.some a result)) choices) = (Answer.parsed a code result)

// Note: unlike Rust's version, this won't rollback
(Parser.guard a:Type head:(Parser Bool) body:(Parser a)) : (Parser (Maybe a))
  (Parser.guard a head body) = λcode (Parser.guard.go a (head code) body)

(Parser.guard.go a:Type head_res:(Answer Bool) body:(Parser a)) : (Answer (Maybe a))
  (Parser.guard.go a (Answer.failed Bool err)             body) = (Answer.failed (Maybe a) err)
  (Parser.guard.go a (Answer.parsed Bool code Bool.false) body) = (Answer.parsed (Maybe a) code (Maybe.none a))
  (Parser.guard.go a (Answer.parsed Bool code Bool.true)  body) = ((Parser.bind a (Maybe a) body λgot (Parser.done _ (Maybe.some a got))) code)

// #############################################################################
// # Kind2                                                                     #
// #############################################################################


// Parsing
// -------

Op : Type 
 Op.ADD : Op
 Op.SUB : Op
 Op.MUL : Op
 Op.DIV : Op
 Op.MOD : Op
 Op.AND : Op
 Op.OR  : Op
 Op.XOR : Op
 Op.SHL : Op
 Op.SHR : Op
 Op.LTE : Op
 Op.LTN : Op
 Op.EQL : Op
 Op.GTE : Op
 Op.GTN : Op
 Op.NEQ : Op

Term : Type
  (Term.let name:Name expr:Term body:Term)           : Term
  (Term.cts name:Name list:(List Term))              : Term
  (Term.o32 op:Op val0:Term val1:Term)               : Term
  (Term.lam name:Name body:Term)                     : Term
  (Term.rfl expr:Term)                               : Term
  (Term.app f:Term x:Term)                           : Term
  (Term.var name:Name)                               : Term
  (Term.n32 value:U32)                               : Term
  (Term.u32)                                         : Term
  (Term.all name:Name type:Term body:Term)           : Term
  (Term.gol name:Name)                               : Term
  (Term.typ)                                         : Term
  (Term.ann expr:Term type:Term)                     : Term
  (Term.hol hash:Name)                               : Term     
  (Term.use name:Name numb:U32)                     : Term
  (Term.eql val0:Term val1:Term)                     : Term
  (Term.rwt name:Name witn:Term goal:Term expr:Term) : Term

// TODO: complete
(Parser.parse_oper) : (Parser Op)
  (Parser.parse_oper) =
    (Parser.grammar Op (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "+")  (Parser.done Op Op.ADD))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "*")  (Parser.done Op Op.MUL))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text (String.cons '/' (String.nil)))  (Parser.done Op Op.DIV))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "%")  (Parser.done Op Op.MOD))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "&")  (Parser.done Op Op.AND))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "|")  (Parser.done Op Op.OR))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "^")  (Parser.done Op Op.XOR))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "<<") (Parser.done Op Op.SHL))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text ">>") (Parser.done Op Op.SHR))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "<=") (Parser.done Op Op.LTE))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "<")  (Parser.done Op Op.LTN))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "==") (Parser.done Op Op.EQL))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text ">=") (Parser.done Op Op.GTE))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text ">")  (Parser.done Op Op.GTN))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "!=") (Parser.done Op Op.NEQ))
                       (List.nil (Parser (Maybe Op)))))))))))))))))))

(Parser.parse_var) : (Parser (Maybe Term))
  (Parser.parse_var) = (Parser.bind String (Maybe Term) (Parser.parse_name) λname (Parser.parse_var.0 name))

(Parser.parse_var.0 name:String) : (Parser (Maybe Term))
  (Parser.parse_var.0 String.nil)   = (Parser.done _ (Maybe.none Term))
  (Parser.parse_var.0 (String.cons x xs)) = (Parser.parse_var.1
    (String.equal (String.cons x xs) "Type")
    (String.equal (String.cons x xs) "U32")
    (Char.is_upper x)
    (Char.is_numeric x)
    (String.cons x xs))

(Parser.parse_var.1 a:U32 b:U32 c:U32 d:U32 str:String) : (Parser (Maybe Term))
  (Parser.parse_var.1 1 b c d str) = (Parser.done (Maybe Term) (Maybe.some Term Term.typ))
  (Parser.parse_var.1 a 1 c d str) = (Parser.done (Maybe Term) (Maybe.some Term Term.u32))
  (Parser.parse_var.1 a b 1 d str) = (Parser.done (Maybe Term) (Maybe.some Term (Term.cts (Name.make str) (List.nil Term))))
  (Parser.parse_var.1 a b c 1 str) = (Parser.done (Maybe Term) (Maybe.some Term (Term.n32 (U32.read str))))
  (Parser.parse_var.1 a b c d str) =
    (Parser.bind Bool (Maybe Term) (Parser.match_text ":") (λis_ann (Parser.parse_var.2 (Bool.if U32 is_ann 1 0) str)))

(Parser.parse_var.2 i:U32 str:String) : (Parser (Maybe Term))
  (Parser.parse_var.2 0 str) = (Parser.done (Maybe Term) (Maybe.some Term (Term.var (Name.make str))))
  (Parser.parse_var.2 1 str) =
    (Parser.bind Term (Maybe Term) Parser.parse_term λterm (Parser.done (Maybe Term) (Maybe.some Term (Term.ann (Term.var (Name.make str)) term))))

(Parser.parse_let) : (Parser (Maybe Term))
(Parser.parse_let) = (Parser.guard Term (Parser.match_text "let")
  (Parser.bind String Term (Parser.parse_name)            λname
  (Parser.bind Bool Term (Parser.match_text ":")   λanns
  (Parser.parse_let_ann anns name))))

(Parser.parse_let_ann b:Bool name:String) : (Parser Term)
  (Parser.parse_let_ann Bool.true name) =
    (Parser.bind Term Term Parser.parse_term            λtype
    (Parser.bind Unit Term (Parser.parse_text "=") λskip
    (Parser.bind Term Term Parser.parse_term            λexpr
    (Parser.bind Term Term Parser.parse_term            λbody
    (Parser.done Term (Term.let (Name.make name) (Term.ann expr type) body))))))
  (Parser.parse_let_ann Bool.false name) =
    (Parser.bind Unit Term (Parser.parse_text "=") λskip
    (Parser.bind Term Term Parser.parse_term            λexpr
    (Parser.bind Term Term Parser.parse_term            λbody
    (Parser.done Term (Term.let (Name.make name) expr body)))))

(Parser.parse_def) : (Parser (Maybe Term))
(Parser.parse_def) = (Parser.guard Term (Parser.match_text "def")
  (Parser.bind String Term (Parser.parse_name)          λname
  (Parser.bind Bool Term (Parser.match_text ":") λanns
  (Parser.parse_def_ann anns name))))

(Parser.parse_def_ann b:Bool name:String) : (Parser Term)
  (Parser.parse_def_ann Bool.true name) =
    (Parser.bind Term Term Parser.parse_term            λtype
    (Parser.bind Unit Term (Parser.parse_text "=") λskip
    (Parser.bind Term Term Parser.parse_term            λexpr
    (Parser.bind Term Term Parser.parse_term            λbody
    (Parser.done Term (Term.def (Name.make name) (Term.ann expr type) body))))))
  (Parser.parse_def_ann Bool.false name) =
    (Parser.bind Unit Term (Parser.parse_text "=") λskip
    (Parser.bind Term Term Parser.parse_term            λexpr
    (Parser.bind Term Term Parser.parse_term            λbody
    (Parser.done Term (Term.def (Name.make name) expr body)))))

(Parser.parse_hol) : (Parser (Maybe Term))
(Parser.parse_hol) = (Parser.guard Term (Parser.match_text "_")
  (Parser.bind String Term (Parser.parse_name) λname
  (Parser.done Term (Term.hol (Name.make name)))))

(Parser.parse_gol) : (Parser (Maybe Term))
(Parser.parse_gol) = (Parser.guard Term (Parser.match_text "?")
  (Parser.bind String Term (Parser.parse_name) λname
  (Parser.done Term (Term.gol (Name.make name)))))

(Parser.parse_lam) : (Parser (Maybe Term))
(Parser.parse_lam) = (Parser.guard Term (Parser.match_text "λ")
  (Parser.bind String Term (Parser.parse_name) λname
  (Parser.bind Term Term (Parser.parse_term)   λbody
  (Parser.done Term (Term.lam (Name.make name) body)))))

(Parser.parse_all) : (Parser (Maybe Term))
(Parser.parse_all) = (Parser.guard Term (Parser.match_text "∀")
  (Parser.bind Unit Term (Parser.parse_text "(") λskip
  (Parser.bind String Term (Parser.parse_name)           λname
  (Parser.bind Unit Term (Parser.parse_text ":")  λskip
  (Parser.bind Term Term (Parser.parse_term)             λtype
  (Parser.bind Unit Term (Parser.parse_text ")") λskip
  (Parser.bind Term Term (Parser.parse_term)             λbody
  (Parser.done Term (Term.all (Name.make name) type body)))))))))

(Parser.parse_rwt) : (Parser (Maybe Term))
(Parser.parse_rwt) = (Parser.guard Term (Parser.match_text "rewrite")
  (Parser.bind String Term (Parser.parse_name)         λname
  (Parser.bind Unit Term (Parser.parse_text "with") λskip
  (Parser.bind Term Term (Parser.parse_term)           λwitn
  (Parser.bind Unit Term (Parser.parse_text "with") λskip
  (Parser.bind Term Term (Parser.parse_term)           λgoal
  (Parser.bind Term Term (Parser.parse_term)           λexpr
  (Parser.done Term (Term.rwt (Name.make name) witn goal expr)))))))))

(Parser.parse_rfl) : (Parser (Maybe Term))
(Parser.parse_rfl) = (Parser.guard Term (Parser.match_text "refl")
  (Parser.bind Term Term (Parser.parse_term) λexpr
  (Parser.done Term (Term.rfl expr))))

(Parser.parse_chr) : (Parser (Maybe Term))
(Parser.parse_chr) = (Parser.guard Term (Parser.match_text "'")
  (Parser.bind U32 Term (Parser.parse_one)             λchr
  (Parser.bind Unit Term (Parser.parse_text "with") λskip
  (Parser.done Term (Term.n32 chr)))))

(Parser.parse_o32) : (Parser (Maybe Term))
  (Parser.parse_o32) = (Parser.guard Term (Parser.peek_conds (List.cons ∀(x:Char)U32 λx(== x '(')
                                                             (List.cons ∀(x:Char)U32 λx(Parser.is_operator x)
                                                             (List.nil  ∀(x:Char)U32))))
    (Parser.bind Unit Term (Parser.parse_text "(") λskip
    (Parser.bind Op Term (Parser.parse_oper)               λoper
    (Parser.bind Term Term (Parser.parse_term)             λval0
    (Parser.bind Term Term (Parser.parse_term)             λval1
    (Parser.bind Unit Term (Parser.parse_text ")") λskip
    (Parser.done Term (Term.o32 oper val0 val1))))))))

(Parser.parse_cts) : (Parser (Maybe Term))
  (Parser.parse_cts) = (Parser.guard Term (Parser.peek_conds (List.cons ∀(x:Char)U32 λx(== x '(')
                                                             (List.cons ∀(x:Char)U32 λx(Char.is_upper x)
                                                             (List.nil  ∀(x:Char)U32))))
    (Parser.bind Unit Term (Parser.parse_text "(")                                                    λskip
    (Parser.bind String Term (Parser.parse_name)                                                              λname
    (Parser.bind (List Term) Term (Parser.parse_until Term (Parser.match_text ")") Parser.parse_term) λargs
    (Parser.done Term (Term.cts (Name.make name) args))))))

(Parser.parse_ann_eql) : (Parser (Maybe Term))
(Parser.parse_ann_eql) = (Parser.guard Term (Parser.match_text "(")
  (Parser.bind Term Term (Parser.parse_term)             λval0
  (Parser.bind Bool Term (Parser.match_text "::") λanns
  (Parser.parse_ann_eql_go anns val0))))

(Parser.parse_ann_eql_go b:Bool val0:Term) : (Parser Term)
  (Parser.parse_ann_eql_go Bool.true val0) =
    (Parser.bind Term Term (Parser.parse_term)             λval1
    (Parser.bind Unit Term (Parser.parse_text ")") λskip
    (Parser.done Term (Term.ann val0 val1))))
  (Parser.parse_ann_eql_go Bool.false val0) =
    (Parser.bind Unit Term (Parser.parse_text "==") λskip
    (Parser.bind Term Term (Parser.parse_term)             λval1
    (Parser.bind Unit Term (Parser.parse_text ")") λskip
    (Parser.done Term (Term.eql val0 val1)))))

(Parser.parse_app) : (Parser (Maybe Term))
(Parser.parse_app) = (Parser.guard Term (Parser.match_text "(")
  (Parser.bind Term Term (Parser.parse_term)                                                                λfunc
  (Parser.bind (List Term) Term (Parser.parse_until Term (Parser.match_text ")") Parser.parse_term) λargs
  (Parser.done Term ((List.fold Term ∀(a:Term)Term args λx(x) λxλtλf(t (Term.app f x))) func)))))

// (Parser.parse_str) : (Parser (Maybe Term))
// (Parser.parse_str) = (Parser.guard Term (Parser.match_text "'")
//   (Parser.bind (List Term) Term (Parser.parse_until Term (Parser.match_text "'") Parser.parse_one) λchars
//   (Parser.done Term (Parser.parse_str_make chars))))

// (Parser.parse_str_make (List Term)) : Term
// (Parser.parse_str_make (List.cons x xs) = (Term.cts (Name.make String.cons) (List.cons (N32 x) (Parser.parse_str_make xs))))
// (Parser.parse_str_make List.nil) = (Term.cts (Name.make String.nil) List.nil)

(Parser.parse_term) : (Parser Term)
(Parser.parse_term) =
  (Parser.bind Term          Term (Parser.parse_term.ini) λini
  (Parser.bind ∀(x:Term)Term Term (Parser.parse_term.end) λend
  (Parser.done Term (end ini))))

(Parser.parse_term.ini) : (Parser Term)
(Parser.parse_term.ini) =
  (Parser.grammar Term (List.cons (Parser (Maybe Term)) Parser.parse_def
                       (List.cons (Parser (Maybe Term)) Parser.parse_let
                       (List.cons (Parser (Maybe Term)) Parser.parse_cts
                       (List.cons (Parser (Maybe Term)) Parser.parse_o32
                       (List.cons (Parser (Maybe Term)) Parser.parse_all
                       (List.cons (Parser (Maybe Term)) Parser.parse_lam
                       (List.cons (Parser (Maybe Term)) Parser.parse_app
                       (List.cons (Parser (Maybe Term)) Parser.parse_chr
                       // (List.cons (Parser (Maybe Term)) Parser.parse_str
                       (List.cons (Parser (Maybe Term)) Parser.parse_gol
                       (List.cons (Parser (Maybe Term)) Parser.parse_rfl
                       (List.cons (Parser (Maybe Term)) Parser.parse_rwt
                       (List.cons (Parser (Maybe Term)) Parser.parse_ann_eql
                       (List.cons (Parser (Maybe Term)) Parser.parse_hol
                       (List.cons (Parser (Maybe Term)) Parser.parse_var
                       (List.nil  (Parser (Maybe Term))))))))))))))))))

(Parser.parse_term.end) : (Parser ∀(x:Term)Term)
(Parser.parse_term.end) =
  let xs = (List.cons (Parser (Maybe ∀(x:Term)Term)) (Parser.done (Maybe ∀(x:Term)Term) (Maybe.some ∀(x:Term)Term λx(x))) 
           (List.nil (Parser (Maybe ∀(x:Term)Term))))

  (Parser.grammar ∀(x:Term)Term xs)

Decl : Type
  (Decl.def_type lhs:Term rhs:Term) : Decl
  (Decl.def_rule lhs:Term rhs:Term) : Decl

KType : Type
  (KType.new lhs:Term rhs:Term) : KType

Rule : Type 
  (Rule.new lhs:Term rhs:Term list:Rule) : Rule
  (Rule.end) : Rule

Func : Type 
  (Func.new lhs:Term rhs:Term rule:Rule) : Func

File : Type 
  (File.new funcs:(Map Func)) : File

(Parser.parse_decl) : (Parser Decl)
(Parser.parse_decl) =
  (Parser.bind Term Decl (Parser.parse_term) λlhs
  (Parser.bind Bool Decl (Parser.match_text ":") λtyp
  (Parser.parse_decl_rhs typ lhs)))

(Parser.parse_decl_rhs typ:Bool lhs:Term) : (Parser Decl)
  (Parser.parse_decl_rhs Bool.true lhs) = (Parser.bind Term Decl (Parser.parse_term) λrhs (Parser.done Decl (Decl.def_type lhs rhs)))
  (Parser.parse_decl_rhs Bool.false lhs) = 
    (Parser.bind Unit Decl (Parser.parse_text "=") λskp
    (Parser.bind Term Decl (Parser.parse_term) λrhs
    (Parser.done Decl (Decl.def_rule lhs rhs))))

(Parser.parse_decls) : (Parser (List Decl))
  (Parser.parse_decls) = (Parser.parse_until Decl λcode((Parser.parse_end) (Parser.skipper code)) Parser.parse_decl)

(Term.def Name Term Term) : Term
(Term.def nm val (Term.var name))                = (U32.if Term (Name.equal name nm) val (Term.var name))
(Term.def nm val (Term.hol hash))                = (Term.hol hash)
(Term.def nm val Term.typ)                       = Term.typ
(Term.def nm val Term.u32)                       = Term.u32
(Term.def nm val (Term.n32 numb))                = (Term.n32 numb)
(Term.def nm val (Term.o32 oper val0 val1))      = (Term.o32 oper (Term.def nm val val0) (Term.def nm val val1))
(Term.def nm val (Term.gol name))                = (Term.gol name)
(Term.def nm val (Term.ann xval xtyp))           = (Term.ann (Term.def nm val xval) (Term.def nm val xtyp))
(Term.def nm val (Term.let name expr body))      = (Term.let name (Term.def nm val expr) (Term.def.body nm val name body))
(Term.def nm val (Term.all name type body))      = (Term.all name (Term.def nm val type) (Term.def.body nm val name body))
(Term.def nm val (Term.lam name body))           = (Term.lam name (Term.def.body nm val name body))
(Term.def nm val (Term.app func argm))           = (Term.app (Term.def nm val func) (Term.def nm val argm))
(Term.def nm val (Term.cts ctid args))           = (Term.cts ctid (Term.def.many nm val args))
(Term.def nm val (Term.eql val0 val1))           = (Term.eql (Term.def nm val val0) (Term.def nm val val1))
(Term.def nm val (Term.rfl expr))                = (Term.rfl (Term.def nm val expr))
(Term.def nm val (Term.rwt name witn goal expr)) = (Term.rwt name (Term.def nm val witn) (Term.def.body nm val name goal) (Term.def nm val expr))

(Term.def.many nm:Name val:Term list:(List Term)) : (List Term)
  (Term.def.many nm val (List.nil Term))      = (List.nil Term)
  (Term.def.many nm val (List.cons Term x xs)) = (List.cons Term (Term.def nm val x) (Term.def.many nm val xs))

(Term.def.body nm:Name val:Term name:Name body:Term) : Term
  (Term.def.body nm val name body) = (Term.def.body.go (Name.equal nm name) nm val body)

(Term.def.body.go i:U32 nm:Name val:Term body:Term) : Term
  (Term.def.body.go 0 nm val body) = (Term.def nm val body)
  (Term.def.body.go 1 nm val body) = body
  
// Utils
// =====

(Ctr.get_id term:Term) : Name
  (Ctr.get_id (Term.cts ctid args)) = ctid
  (Ctr.get_id term)                 = (Name.make "?")

(Var.get_name term:Term) : Name
  (Var.get_name (Term.var name)) = name
  (Var.get_name x) = (Name.make "_")

(Arg.get term:Term cont:∀(x:Name)∀(y:Term)Term) : Term
  (Arg.get (Term.ann var expr) cont) = (cont (Var.get_name var) expr)
  (Arg.get term                cont) = (cont (Name.make "_") term)


// FIXME: this should be replaced by proper user of Maybe
(Func.empty) : Func
(Func.empty) = (Func.new (Term.var (Name.make "?")) (Term.var (Name.make "?")) Rule.end)

(Func.set_type func:Func new_lty:Term new_rty:Term) : Func
(Func.set_type (Func.new lty rty rules) new_lty new_rty) = (Func.new new_lty new_rty rules)

(Func.add_rule func:Func lhs:Term rhs:Term) : Func
(Func.add_rule (Func.new lty rty rules) lhs rhs) = (Func.new lty rty (Rule.new lhs rhs rules))

(Func.get_name func:Func file:File) : String
(Func.get_name (Func.new lty rty rules) file) = (Name.get_string (Ctr.get_id lty))

(Func.get func:Func cont:∀(lhs:Term)∀(rhs:Term)∀(rules:Rule)Func) : Func
  (Func.get (Func.new lty rty rules) cont) = (cont lty rty rules)

(Func.get_rules func:Func) : Rule
(Func.get_rules (Func.new lty rty rules)) = rules

(File.make decls:(List Decl)) : File
// (File.make decls) = (File.new (File.make.go decls (Map.empty Func)))

(File.make.go list:(List Decl) file:(Map Func)) : File
  (File.make.go (List.cons Decl (Decl.def_type lhs rhs) decls) file) =
    let ctid = (Ctr.get_id lhs)
    let func = (Func.new lhs rhs Rule.end)
    (File.make.go decls (Map.set Func file (Name.get_hash ctid) func))

  // FIXME: infer lambda
  // (File.make.go (List.cons Decl (Decl.def_rule lhs rhs) decls) file) =
  //   let ctid = (Ctr.get_id lhs)
  //   let func = λfunc (Func.add_rule func (File.make.lhs lhs rhs) rhs)
  //   (File.make.go decls (Map.mut Func file (Name.GetHash ctid) func))

  (File.make.go (List.nil Decl) file) = (File.new file)

// Builds the left-hand side of a rule, annotating variable usage counts.
// TODO: use different constructor names
// FIXME: is this really needed? benchmark without
(File.make.lhs lhs:Term rhs:Term) : Term
  (File.make.lhs (Term.var name)      rhs) = (Term.use name (Uses name rhs))
  (File.make.lhs (Term.n32 numb)      rhs) = (Term.n32 numb)
  (File.make.lhs (Term.cts ctid args) rhs) = (Term.cts ctid (File.make.lhs.many args rhs))
  (File.make.lhs (Term.rfl expr)      rhs) = (Term.rfl (File.make.lhs expr rhs))
  (File.make.lhs term                 rhs) = term

(File.make.lhs.many lhs:(List Term) rhs:Term) : (List Term)
  (File.make.lhs.many  (List.nil Term)       rhs) = (List.nil Term)
  (File.make.lhs.many (List.cons Term x xs) rhs) = (List.cons Term (File.make.lhs x rhs) (File.make.lhs.many xs rhs))

(File.get_funcs file:File) : (Map Func)
  (File.get_funcs (File.new funs)) = funs

// TODO: infer
(File.got_func file:File ctid:U32) : (Pair File (Maybe Func))
  // (File.got_func (File.new funs) ctid) =
  //   (Pair.get (Map Func) (Maybe Func) _ (Map.get Func funs (Name.get_hash ctid)) λfuns λgot
  //   (Pair.new File (Maybe Func) (File.new funs) got))

// TODO: infer
(File.is_ctr file:File ctid:U32) : U32
// (File.is_ctr (File funs) ctid) =
//   (Pair.get _ _ _ (Map.get Func funs (Name.get_hash ctid)) λfuns λgot
//   (Maybe.case Func U32 got 1 λfunc(File.is_ctr.func func)))

(File.is_ctr.func func:Func) : U32
  (File.is_ctr.func (Func.new lty rty Rule.end))                 = 1
  (File.is_ctr.func (Func.new lty rty (Rule.new lhs rhs rules))) = 0


// Stringifying
// ------------


// Evaluation
// ----------

// Counts free occurrences of a name
(Uses name:Name term:Term) : U32
  (Uses nm (Term.var name))                = (Name.equal name nm)
  (Uses nm (Term.use name numb))           = (Name.equal name nm)
  (Uses nm (Term.hol hash))                = 0
  (Uses nm Term.typ)                       = 0
  (Uses nm Term.u32)                       = 0
  (Uses nm (Term.n32 numb))                = 0
  (Uses nm (Term.o32 oper val0 val1))      = (+ (Uses nm val0) (Uses nm val1))
  (Uses nm (Term.gol name))                = 0
  (Uses nm (Term.ann xval xtyp))           = (Uses nm xval)
  (Uses nm (Term.let name expr body))      = (+ (Uses nm expr) (Uses.shadow (Name.equal nm name) nm body))
  (Uses nm (Term.all name type body))      = (+ (Uses nm type) (Uses.shadow (Name.equal nm name) nm body))
  (Uses nm (Term.lam name body))           = (Uses.shadow (Name.equal nm name) nm body)
  (Uses nm (Term.app func argm))           = (+ (Uses nm func) (Uses nm argm))
  (Uses nm (Term.cts ctid args))           = (Uses.many nm args)
  (Uses nm (Term.eql val0 val1))           = (+ (Uses nm val0) (Uses nm val1))
  (Uses nm (Term.rfl expr))                = (Uses nm expr)
  (Uses nm (Term.rwt name witn goal expr)) = (+ (Uses nm witn) (+ (Uses.shadow (Name.equal nm name) nm goal) (Uses nm expr)))

(Uses.many name:Name list:(List Term)) : U32
  (Uses.many nm (List.nil Term))                = 0
  (Uses.many nm (List.cons Term x xs))          = (+ (Uses nm x) (Uses.many nm xs))
  
(Uses.shadow cond:U32 name:Name body:Term) : U32
  (Uses.shadow 0 nm body)             = (Uses nm body)
  (Uses.shadow 1 nm body)             = 0

(Clone a:Type n:U32 name:Name term:a ctx:(List (Pair Name a))) : (List (Pair Name a))
  (Clone a 0 name term ctx) = ctx
  (Clone a 1 name term ctx) = (List.cons (Pair Name a) (Pair.new Name a name term) ctx)
  (Clone a n name term ctx) = (List.cons (Pair Name a) (Pair.new Name a name term) (Clone a (- n 1) name term ctx))

(CloneFor a:Type body:Term name:Name term:a ctx:(List (Pair Name a))) : (List (Pair Name a))
  (CloneFor a body name term ctx) = (Clone a (Uses name body) name term ctx)

HTerm : Type
  (HTerm.let name:Name expr:HTerm body:HTerm)            : HTerm
  (HTerm.cts name:Name list:(List HTerm))                : HTerm
  (HTerm.o32 op:Op val0:HTerm val1:HTerm)                : HTerm
  (HTerm.lam name:Name body:HTerm)                       : HTerm
  (HTerm.rfl expr:HTerm)                                 : HTerm
  (HTerm.app f:HTerm x:HTerm)                            : HTerm
  (HTerm.var name:Name)                                  : HTerm
  (HTerm.n32 value:U32)                                  : HTerm
  (HTerm.u32)                                            : HTerm
  (HTerm.all name:Name type:HTerm body:HTerm)            : HTerm
  (HTerm.gol name:Name)                                  : HTerm
  (HTerm.typ)                                            : HTerm
  (HTerm.ann expr:HTerm type:HTerm)                      : HTerm
  (HTerm.hol hash:Name)                                  : HTerm     
  (HTerm.use name:Name numb:U32)                         : HTerm
  (HTerm.eql val0:HTerm val1:HTerm)                      : HTerm
  (HTerm.rwt name:Name witn:HTerm goal:HTerm expr:HTerm) : HTerm

(High file:File term:Term vars:(List (Pair String HTerm))) : HTerm
  // (High file term vars) = (Triple.get File (List (Pair String HTerm)) HTerm (Triple File (List (Pair String HTerm)) HTerm) (High.go term file vars) λfile λvars λterm term)

(High.go term:Term file:File vars:(List (Pair String HTerm))) : (Triple File (List (Pair String HTerm)) HTerm)

  // (High.go (Term.var name) file vars) = (HighFind name file vars)
  //   (HighFind name:Name file:File list:(List (Pair String HTerm))) : (Triple File (List (Pair String HTerm)) HTerm) 
  //   (HighFind name file (List.nil (Pair String HTerm))) = (Triple.new File (List (Pair String HTerm)) HTerm file (List.nil (Pair String HTerm)) (HTerm.var name))
  //   (HighFind name file (List.cons (Pair String HTerm) (Pair.new var val) vars)) = (HighFound (Name.equal name var) name var val file vars)
  //     (HighFound 1 name var val file vars) = (Triple.new File (List (Pair String HTerm)) HTerm file vars val)
  //     (HighFound 0 name var val file vars) =
  //       (Triple.get File (List (Pair String HTerm)) HTerm (Triple File (List (Pair String HTerm)) HTerm) (HighFind name file vars) λfile λvars λgot
  //       (Triple.new File (List (Pair String HTerm)) HTerm file (List.cons (Pair String HTerm) (Pair var val) vars) got))

  (High.go (Term.use name count) file vars) =
    (High.go (Term.var name) file vars)

  (High.go (Term.ann xval xtyp) file vars) =
    (High.go xval file vars)

  (High.go Term.typ file vars) =
    (Triple.new File (List (Pair String HTerm)) HTerm file vars HTerm.typ)

  (High.go Term.u32 file vars) =
    (Triple.new File (List (Pair String HTerm)) HTerm file vars HTerm.u32)

  (High.go (Term.n32 numb) file vars) =
    (Triple.new File (List (Pair String HTerm)) HTerm file vars (HTerm.n32 numb))

  (High.go (Term.o32 oper val0 val1) file vars) =
    (Triple.get File (List (Pair String HTerm)) HTerm (Triple File (List (Pair String HTerm)) HTerm) (High.go val0 file vars) λfile λvars λval0
    (Triple.get File (List (Pair String HTerm)) HTerm (Triple File (List (Pair String HTerm)) HTerm) (High.go val1 file vars) λfile λvars λval1
    (Triple.new File (List (Pair String HTerm)) HTerm file vars (HTerm.o32 oper val0 val1))))

  (High.go (Term.gol name) file vars) =
    (Triple.new File (List (Pair String HTerm)) HTerm file vars (HTerm.gol name))

  // (High.go (Term.all name type body) file vars) =
  //   (Triple.get File (List (Pair String HTerm)) HTerm (Triple File (List (Pair String HTerm)) HTerm) (High.go type file vars) λfile λvars λtype
  //   (Triple.get File (List (Pair String HTerm)) HTerm (Triple File (List (Pair String HTerm)) HTerm) (High.go body file (CloneFor body name $x vars)) λfile λvars λbody
  //   (Triple.new File (List (Pair String HTerm)) HTerm file vars (HTerm.all type λ$x body))))

  // (High.go (Term.let name expr body) file vars) =
  //   (Triple.get File (List (Pair String HTerm)) HTerm (Triple File (List (Pair String HTerm)) HTerm) (High.go expr file vars) λfile λvars λexpr
  //   (Triple.get File (List (Pair String HTerm)) HTerm (Triple File (List (Pair String HTerm)) HTerm) (High.go body file (CloneFor HTerm body name expr vars)) λfile λvars λbody
  //   (Triple.new File (List (Pair String HTerm)) HTerm file vars body)))

  // (High.go (Term.app func argm) file vars) =
  //   (Triple.get File (List (Pair String HTerm)) HTerm (Triple File (List (Pair String HTerm)) HTerm) (High.go func file vars) λfile λvars λfunc
  //   (Triple.get File (List (Pair String HTerm)) HTerm (Triple File (List (Pair String HTerm)) HTerm) (High.go argm file vars) λfile λvars λargm
  //   (Triple.new File (List (Pair String HTerm)) HTerm file vars (HApply func argm))))
    
  // (High.go (Term.cts ctid args) file vars) =
  //   (Pair.get File (Maybe Func) (Pair File (Maybe Func)) (File.got_func file ctid)     λfile λfunc
  //   (Triple.get File (List (Pair String HTerm)) HTerm (Triple File (List (Pair String HTerm)) HTerm) (High.go.many args file vars) λfile λvars λargs
  //   (High.go.cts func (HTerm.cts ctid args) file vars)))


  // (High.go (Term.arg name expr) file vars) = 
  // (High.go expr file vars)

  
  (High.go (Term.eql val0 val1) file vars) =
    (Triple.get File (List (Pair String HTerm)) HTerm (Triple File (List (Pair String HTerm)) HTerm) (High.go val0 file vars) λfile λvars λval0
    (Triple.get File (List (Pair String HTerm)) HTerm (Triple File (List (Pair String HTerm)) HTerm) (High.go val1 file vars) λfile λvars λval1
    (Triple.new File (List (Pair String HTerm)) HTerm file vars (HTerm.eql val0 val1))))

  (High.go (Term.rfl expr) file vars) =
    (Triple.get File (List (Pair String HTerm)) HTerm (Triple File (List (Pair String HTerm)) HTerm) (High.go expr file vars) λfile λvars λexpr
    (Triple.new File (List (Pair String HTerm)) HTerm file vars (HTerm.rfl expr)))

  (High.go (Term.rwt name witn goal expr) file vars) =
    (Triple.get File (List (Pair String HTerm)) HTerm (Triple File (List (Pair String HTerm)) HTerm) (High.go expr file vars) λfile λvars λexpr
    (Triple.new File (List (Pair String HTerm)) HTerm file vars expr))


// (High.go.many xs:(List Term) file:File vars::(List (Pair String HTerm))) : File
  // (High.go.many Nil file vars) =
  //   (Trip.new File (List (Pair String HTerm)) HTerm file vars Nil)
  // (High.go.many (Cons x xs) file vars) =
  //   (Triple.get (List (Pair String HTerm)) HTerm (Triple File (List (Pair String HTerm)) HTerm) (High.go x file vars)       λfile λvars λx
  //   (Triple.get (List (Pair String HTerm)) HTerm (Triple File (List (Pair String HTerm)) HTerm) (High.go.many xs file vars) λfile λvars λxs
  //   (Triple.new File (List (Pair String HTerm)) HTerm file vars (Cons x xs))))

   (High.go (Term.hol hash) file vars) =
    (Triple.new File (List (Pair String HTerm)) HTerm file vars (HTerm.hol hash))
