// Kind2 implemented in Kind2
// ==========================

// U32
// ===

(U32.if a:Type cond:U32 if_t:a if_f:a): a
  (U32.if a 0 t f) = f
  (U32.if a 1 t f) = t

(U32.and a:U32 b:U32): U32
  (U32.and 0 b) = 0
  (U32.and 1 b) = b

(U32.not a:U32): U32
  (U32.not 0) = 1
  (U32.not 1) = 0

(U32.read str:String) : U32
  (U32.read str) = (U32.read.go str 0)

(U32.read.go str:String r:U32) : U32
  (U32.read.go String.nil         r) = r
  (U32.read.go (String.cons x xs) r) = (U32.if U32 (& (<= '0' x) (<= x '9')) (U32.read.go xs (+ (* r 10) (- x '0'))) 0) 

// Unit
// ====

Unit: Type
  Unit.new : Unit

// Bool
// ====

Bool: Type
  Bool.true  : Bool
  Bool.false : Bool

(Bool.if a:Type Bool if_t:a if_f:a): a
  (Bool.if a Bool.false t f) = f
  (Bool.if a Bool.true  t f) = t

// Pair
// ====

(Pair a:Type b:Type): Type
  (Pair.new a:Type b:Type fst:a snd:b): (Pair a b)

(Pair.get a:Type b:Type c:Type p:(Pair a b) f:∀(x:a)∀(y:b)c): c
  (Pair.get a b c (Pair.new a b x y) f) = (f x y)

(Pair.fst a:Type b:Type p:(Pair a b)): a
  (Pair.fst a b (Pair.new a b x y)) = x

(Pair.snd a:Type b:Type p:(Pair a b)): b
  (Pair.snd a b (Pair.new a b x y)) = y

(Pair.fst.mut a:Type b:Type p:(Pair a b) f:∀(x:a)a): (Pair a b)
  (Pair.fst.mut a b (Pair.new a b x y) f) = (Pair.new a b (f x) y)

(Pair.snd.mut a:Type b:Type p:(Pair a b) f:∀(x:b)b): (Pair a b)
  (Pair.snd.mut a b (Pair.new a b x y) f) = (Pair.new a b x (f y))


// Triple
// ======

(Triple a:Type b:Type c:Type): Type
  (Triple.new a:Type b:Type c:Type fst:a snd:b trd:c): (Triple a b c)

(Triple.get a:Type b:Type c:Type d:Type t:(Triple a b c) f:∀(x:a)∀(y:b)∀(z:c)d): d
  (Triple.get a b c d (Triple.new a b c x y z) f) = (f x y z)

// Tuple2
// ======

(Tuple2 a:Type b:Type): Type
  (Tuple2 a b) = ∀(p: Type) ∀(new: ∀(x0: a) ∀(x1: b) p) p

(Tuple2.new a:Type b:Type x0:a x1:b): (Tuple2 a b)
  (Tuple2.new a b x0 x1) = λp λnew (new x0 x1)

(Tuple2.get a:Type b:Type c:Type p:(Tuple2 a b) f:∀(x:a)∀(y:b)c): c
  (Tuple2.get a b c tup f) = (tup c f)

// Maybe
// =====

(Maybe a:Type): Type
  (Maybe.none a:Type)     : (Maybe a)
  (Maybe.some a:Type x:a) : (Maybe a)

(Maybe.case a:Type r:Type m:(Maybe a) none:r some:∀(x:a)r): r
  (Maybe.case a r (Maybe.some a x) case_none case_some) = (case_some x)
  (Maybe.case a r (Maybe.none a)   case_none case_some) = case_none

// List
// ====

(List a:Type): Type
  (List.nil a:Type)                       : (List a)
  (List.cons a:Type head:a tail:(List a)) : (List a)

(List.map a:Type b:Type l:(List a) f:∀(x:a)b): (List b)
  (List.map a b (List.nil a) f)            = (List.nil b)
  (List.map a b (List.cons a head tail) f) = (List.cons b (f head) (List.map a b tail f))

(List.reverse a:Type l:(List a)): (List a)
  (List.reverse a l) = (List.reverse.go a l (List.nil a))

(List.reverse.go a:Type l:(List a) r:(List a)): (List a)
  (List.reverse.go a (List.nil a)            r) = r
  (List.reverse.go a (List.cons a head tail) r) = (List.reverse.go a tail (List.cons a head r))

(List.length a:Type l:(List a)): U32
  (List.length a (List.nil a))            = 0
  (List.length a (List.cons a head tail)) = (+ 1 (List.length a tail))

(List.is_empty a:Type l:(List a)): U32
  (List.is_empty a (List.nil a))            = 1
  (List.is_empty a (List.cons a head tail)) = 0

(List.concat a:Type xs:(List a) ys:(List a)): (List a)
  (List.concat a (List.nil a)       ys) = ys
  (List.concat a (List.cons a x xs) ys) = (List.cons a x (List.concat a xs ys))

(List.fold a:Type r:Type xs:(List a) nil:r cons:∀(x:a)∀(xs:r)r): r
  (List.fold a r (List.nil a)       nil cons) = nil
  (List.fold a r (List.cons a x xs) nil cons) = (cons x (List.fold a r xs nil cons))

(List.to_map a:Type list:(List (Pair U32 a))) : (Map a)
  (List.to_map a list) = (List.to_map.go a list (Map.empty a))

(List.to_map.go a:Type list:(List (Pair U32 a)) map:(Map a)) : (Map a)
  (List.to_map.go a (List.nil (Pair U32 a))                              map) = map
  (List.to_map.go a (List.cons (Pair U32 a) (Pair.new U32 a key val) xs) map) = (List.to_map.go a xs (Map.set a map key val))

// Name
// ====

Name : Type
  (Name.new str:String hash:U32) : Name

(Name.make str:String) : Name
  (Name.make str) = (Name.new str (String.hash str))

(Name.get_hash name:Name) : U32
  (Name.get_hash (Name.new str hash)) = hash

(Name.get_string name:Name) : String
  (Name.get_string (Name.new str hash)) = str
  (Name.get_string (Name.new str hash)) = (String.concat "TODO: Name.get_string" str)

(Name.equal a_name:Name b_name:Name) : U32
  (Name.equal (Name.new a_str a_hash) (Name.new b_str b_hash)) = (== a_hash b_hash)

// String
// ======

Char : Type
  Char = U32

String : Type
  (String.cons head:Char tail:String) : String
  (String.nil): String

// Returns true if a string is empty
(String.is_empty s:String): Bool
  (String.is_empty String.nil)         = Bool.true
  (String.is_empty (String.cons x xs)) = Bool.false

// Concatenates two strings
(String.concat a:String b:String) : String
  (String.concat String.nil         ys) = ys
  (String.concat (String.cons x xs) ys) = (String.cons x (String.concat xs ys))

// Concatenates a list of strings
(String.flatten a:(List String)) : String
  (String.flatten (List.nil a))            = String.nil
  (String.flatten (List.cons String x xs)) = (String.concat x (String.flatten xs))

// Returns true if two strings are equal
(String.equal xs:String ys:String) : U32
  (String.equal String.nil         String.nil)         = 1
  (String.equal (String.cons x xs) (String.cons y ys)) = (& (== x y) (String.equal xs ys))
  (String.equal xs             ys)             = 0

(String.hash xs:String) : U32
  (String.hash str) = (String.hash.go str 0)

(String.hash.go xs:String hash:U32) : U32
  (String.hash.go String.nil         hash) = hash
  (String.hash.go (String.cons x xs) hash) = (String.hash.go xs (+ (- (<< hash 5) hash) x))

(String.map xs:String f:∀(x:Char)Char) : String
  (String.map String.nil         f) = String.nil
  (String.map (String.cons x xs) f) = (String.cons (f x) (String.map xs f))

(String.join xs:(List String) sep:String) : String
  (String.join (List.nil String)                       sep) = String.nil
  (String.join (List.cons String x (List.nil String))  sep) = x
  (String.join (List.cons String x xs)                 sep) = (String.flatten (List.cons String x (List.cons String (String.join xs sep) (List.nil String))))

// Map
// ===

(Map a:Type) : Type
  (Map.empty a:Type)                         : (Map a)
  (Map.entry a:Type value:a)                 : (Map a)
  (Map.nodes a:Type lft:(Map a) rgt:(Map a)) : (Map a)

(Map.length a:Type tree:(Map a)) : U32
  (Map.length a (Map.empty a        )) = 0
  (Map.length a (Map.entry a     val)) = 1
  (Map.length a (Map.nodes a lft rgt)) = (+ (Map.length a lft) (Map.length a rgt))

(Map.get a:Type tree:(Map a) key:U32) : (Pair (Map a) (Maybe a))
(Map.get a tree key) = (Map.get.go a 32 tree key (λx x))

(Map.get.go a:Type n:U32 tree:(Map a) key:U32 self:∀(x:(Map a))(Map a)) : (Pair (Map a) (Maybe a))
  (Map.get.go a n (Map.empty a) key self) =
    (Pair.new (Map a) (Maybe a) (self (Map.empty a)) (Maybe.none a))
  (Map.get.go a n (Map.entry a val) key self) =
    (Pair.new (Map a) (Maybe a) (self (Map.entry a val)) (Maybe.some a val))
  (Map.get.go a n (Map.nodes a lft rgt) key self) =
    (Map.get.go.nodes a (& (>> key (- n 1)) 1) (- n 1) key lft rgt self)

(Map.get.go.nodes a:Type i:U32 n:U32 key:U32 lft:(Map a) rgt:(Map a) self:∀(x:(Map a))(Map a)) : (Pair (Map a) (Maybe a))
  (Map.get.go.nodes a 0 n key lft rgt self) =
    (Map.get.go a n lft key λx(self (Map.nodes a x rgt)))
  (Map.get.go.nodes a 1 n key lft rgt self) =
    (Map.get.go a n rgt key λx(self (Map.nodes a lft x)))

(Map.delete a:Type tree:(Map a) key:U32) : (Map a)
(Map.delete a tree key) = (Map.delete.go a 32 tree key)

(Map.delete.go a:Type n:U32 tree:(Map a) key:U32) : (Map a)
  (Map.delete.go a n (Map.nodes a lft rgt) key) =
    (Map.delete.go.nodes a (& (>> key (- n 1)) 1) (- n 1) lft rgt key)
  (Map.delete.go a n tree key) = (Map.empty a)

(Map.delete.go.nodes a:Type i:U32 n:U32 lft:(Map a) rgt:(Map a) key:U32) : (Map a)
  (Map.delete.go.nodes a 0 n lft rgt key) =
    (Map.nodes a (Map.delete.go a n lft key) rgt)
  (Map.delete.go.nodes a 1 n lft rgt key) =
    (Map.nodes a lft (Map.delete.go a n rgt key))

(Map.set a:Type tree:(Map a) key:U32 val:a) : (Map a)
(Map.set a tree key val) = (Map.set.go a 32 tree key val)

(Map.set.go a:Type n:U32 tree:(Map a) key:U32 val:a) : (Map a)
  (Map.set.go a 0 tree          key val) = (Map.entry a val)
  (Map.set.go a n (Map.empty a) key val) =
    (Map.set.go.empty a (& (>> key (- n 1)) 1) (- n 1) key val)
  (Map.set.go a n (Map.nodes a lft rgt) key val) =
    (Map.empty a)

(Map.set.go.empty a:Type i:U32 n:U32 key:U32 val:a) : (Map a)
  (Map.set.go.empty a 0 n key val) =
    (Map.nodes a (Map.set.go a n (Map.empty a) key val) (Map.empty a))
  (Map.set.go.empty a 1 n key val) =
    (Map.nodes a (Map.empty a) (Map.set.go a n (Map.empty a) key val))

(Map.set.go.nodes a:Type i:U32 n:U32 key:U32 lft:(Map a) rgt:(Map a) val:a) : (Map a)
  (Map.set.go.nodes a 0 n key lft rgt val) =
    (Map.nodes a (Map.set.go a n lft key val) rgt)
  (Map.set.go.nodes a 1 n key lft rgt val) =
    (Map.nodes a lft (Map.set.go a n rgt key val))

(Map.mut a:Type tree:(Map a) key:U32 f:∀(v:a)a) : (Map a)
(Map.mut a tree key f) = (Map.mut.go a 32 tree key f)

(Map.mut.go a:Type n:U32 tree:(Map a) key:U32 f:∀(v:a)a) : (Map a)
  (Map.mut.go a 0 (Map.entry a x) key f) = (Map.entry a (f x))
  (Map.mut.go a 0 tree            key f) = tree
  (Map.mut.go a n (Map.empty a)   key f) =
    (Map.mut.go.empty a (& (>> key (- n 1)) 1) (- n 1) key f)
  (Map.mut.go a n (Map.nodes a lft rgt) key f) =
    (Map.mut.go.nodes a (& (>> key (- n 1)) 1) (- n 1) key lft rgt f)

(Map.mut.go.empty a:Type i:U32 n:U32 key:U32 f:∀(v:a)a) : (Map a)
  (Map.mut.go.empty a 0 n key f) =
    (Map.nodes a (Map.mut.go a n (Map.empty a) key f) (Map.empty a))
  (Map.mut.go.empty a 1 n key f) =
    (Map.nodes a (Map.empty a) (Map.mut.go a n (Map.empty a) key f))

(Map.mut.go.nodes a:Type i:U32 n:U32 key:U32 lft:(Map a) rgt:(Map a) f:∀(v:a)a) : (Map a)
  (Map.mut.go.nodes a 0 n key lft rgt f) =
    (Map.nodes a (Map.mut.go a n lft key f) rgt)
  (Map.mut.go.nodes a 1 n key lft rgt f) =
    (Map.nodes a lft (Map.mut.go a n rgt key f))

(Map.to_list a:Type val:(Map a)) : (List (Pair U32 a))
  (Map.to_list a val) = ((Map.to_list.go a val 0) (List.nil (Pair U32 a)))

(Map.to_list.go a:Type val:(Map a) key:U32) : ∀(x:(List (Pair U32 a)))(List (Pair U32 a))
  (Map.to_list.go a (Map.empty a)     key) = λx x
  (Map.to_list.go a (Map.entry a val) key) = λx
    (List.cons (Pair U32 a) (Pair.new U32 a key val) x)
  (Map.to_list.go a (Map.nodes a lft rgt) key) = λx
    ((Map.to_list.go a lft (* key 2)) ((Map.to_list.go a rgt (+ (* key 2) 1)) x))

(Map.values a:Type val:(Map a)) : (List a)
  (Map.values a val) = ((Map.values.go a val) (List.nil a))

(Map.values.go a:Type val:(Map a)) : ∀(x:(List a))(List a)
  (Map.values.go a (Map.empty a)        ) = λx x
  (Map.values.go a (Map.entry a val    )) = λx (List.cons a val x)
  (Map.values.go a (Map.nodes a lft rgt)) = λx ((Map.values.go a lft) ((Map.values.go a rgt) x))

// Parser
// ======

Code : Type
  Code = String

(Answer a:Type): Type
  (Answer.parsed a:Type code:(Code) result:a) : (Answer a)
  (Answer.failed a:Type String) : (Answer a)

(Parser a:Type): Type
  (Parser a) = ∀(x: Code) (Answer a)

(Parser.is_name_char chr:Char) : Char
  (Parser.is_name_char chr) = 
  let is_letter = (| (& (<= 'a' chr) (<= chr 'z')) (& (<= 'A' chr) (<= chr 'Z')))
  let is_number = (& (<= '0' chr) (<= chr '9'))
  let is_symbol = (| (== '_' chr) (== '.' chr))
  (| is_letter (| is_number is_symbol))

(Char.is_upper chr:Char) : U32
(Char.is_upper chr) =
  (& (<= 'A' chr) (<= chr 'Z'))

(Char.is_lower chr:Char) : U32
(Char.is_lower chr) =
  (& (<= 'a' chr) (<= chr 'z'))

(Char.is_numeric chr:Char) : U32
(Char.is_numeric chr) =
  (& (<= '0' chr) (<= '9' chr))

(Parser.is_operator chr:Char) : U32
  (Parser.is_operator chr) =
    (| (== '+' chr)
    (| (== '-' chr)
    (| (== '*' chr)
    (| (== '/' chr)
    (| (== '%' chr)
    (| (== '&' chr)
    (| (== '|' chr)
    (| (== '^' chr)
    (| (== '<' chr)
    (| (== '>' chr)
    (| (== '=' chr)
    (| (== '!' chr)
       0))))))))))))

(Parser.bind a:Type b:Type a_parser:(Parser a) f:(∀(x:a)(Parser b))): (Parser b)
  (Parser.bind a b a_parser f) = λcode (Parser.bind.go a b f (a_parser code))

(Parser.bind.go a:Type b:Type f:(∀(x:a)(Parser b)) a_res:(Answer a)) : (Answer b)
  (Parser.bind.go a b f (Answer.parsed a code a_val)) = (f a_val code)
  (Parser.bind.go a b f (Answer.failed a err))        = (Answer.failed b err)

(Parser.done a:Type value:a) : (Parser a)
  (Parser.done a value) = λcode (Answer.parsed a code value)

(Char.is_space chr:Char) : U32
  (Char.is_space chr) = (| (== 10 chr) (== 32 chr))

(Parser.parse_one) : (Parser U32)
  (Parser.parse_one) = λcode (Parser.parse_one.go code)

(Parser.parse_one.go code:String) : (Answer U32)
  (Parser.parse_one.go (String.cons x xs)) = (Answer.parsed U32 xs x)
  (Parser.parse_one.go String.nil)         = (Answer.parsed U32 String.nil 0)

(Parser.get_name) : ∀(code: Code)(Pair String String)
  (Parser.get_name) = λcode (Parser.get_name.go code)

(Parser.get_name.go code:Code) : (Pair String String)
  (Parser.get_name.go String.nil)              = (Pair.new String String String.nil String.nil)
  (Parser.get_name.go (String.cons head tail)) = (Parser.get_name.go_1 (Parser.is_name_char head) head tail)

(Parser.get_name.go_1 cond:U32 head:Char tail:String) : (Pair String String)
  (Parser.get_name.go_1 0 head tail) = (Pair.new String String (String.cons head tail) String.nil)
  (Parser.get_name.go_1 1 head tail) = (Parser.get_name.go_2 head (Parser.get_name.go tail))

(Parser.get_name.go_2 head:Char name_pair:(Pair String String)) : (Pair String String)
  (Parser.get_name.go_2 head (Pair.new Code String code name)) = (Pair.new Code String code (String.cons head name))

(Parser.matcher consume:Bool text:(List (∀(x:Char)U32))) : (Parser Bool)
  (Parser.matcher consume text) = λcode (Parser.matcher.go text code consume λx(x))

(Parser.matcher.go text:(List (∀(x:Char)U32)) code:Code consume:Bool redo:(∀(x:String)Code)) : (Answer Bool)
  (Parser.matcher.go (List.nil  (∀(x:Char)U32))      ys             consume redo) = (Answer.parsed Bool ((Bool.if ∀(x:String)String consume λx(x) redo) ys) Bool.true)
  (Parser.matcher.go (List.cons (∀(x:Char)U32) x xs) String.nil         consume redo) = (Answer.parsed Bool (redo String.nil) Bool.false)
  (Parser.matcher.go (List.cons (∀(x:Char)U32) x xs) (String.cons y ys) consume redo) = (Parser.matcher.go.test (x y) xs y ys consume redo)

(Parser.matcher.go.test cond:U32 xs:(List (∀(x:Char)U32)) y:Char ys:String consume:Bool redo:(∀(x:String)Code)) : (Answer Bool)
  (Parser.matcher.go.test 0 xs y ys consume redo) = (Answer.parsed Bool (redo (String.cons y ys)) Bool.false)
  (Parser.matcher.go.test 1 xs y ys consume redo) = (Parser.matcher.go xs ys consume λk(redo (String.cons y k)))

(Parser.text_comparer str:String) : (List ∀(c:Char)U32)
  (Parser.text_comparer String.nil)         = (List.nil  ∀(c:Char)U32)
  (Parser.text_comparer (String.cons x xs)) = (List.cons ∀(c:Char)U32 λc(== x c) (Parser.text_comparer xs))

(Parser.peek_conds conds:(List (∀(x:Char)U32))) : (Parser Bool)
  (Parser.peek_conds conds) = λcode ((Parser.matcher Bool.false conds) (Parser.skipper code))

(Parser.peek_text text:String) : (Parser Bool)
  (Parser.peek_text text) = λcode ((Parser.matcher Bool.false (Parser.text_comparer text)) (Parser.skipper code))

(Parser.match_conds conds:(List (∀(x:Char)U32))) : (Parser Bool)
  (Parser.match_conds conds) = λcode ((Parser.matcher Bool.true conds) (Parser.skipper code))

(Parser.match_text_here text:String) : (Parser Bool)
  (Parser.match_text_here text) = λcode ((Parser.matcher Bool.true (Parser.text_comparer text)) code)

(Parser.match_text text:String) : (Parser Bool)
  (Parser.match_text text) = λcode ((Parser.matcher Bool.true (Parser.text_comparer text)) (Parser.skipper code))

(Parser.parse_text_here text:String) : (Parser Unit)
  (Parser.parse_text_here text) = (Parser.bind Bool Unit (Parser.match_text_here text) λgot(Parser.text_here_got got))
  (Parser.parse_text_here text) = (Parser.bind Bool Unit (Parser.match_text_here text) λgot(Parser.text_here_got got))

(Parser.text_here_got got:Bool) : (Parser Unit)
  (Parser.text_here_got (Bool.false)) = λcode (Answer.failed Unit "Syntax Error.") 
  (Parser.text_here_got (Bool.true))  = (Parser.done Unit Unit.new)

(Parser.parse_text text:String) : (Parser Unit)
  (Parser.parse_text text) = λcode ((Parser.parse_text_here text) (Parser.skipper code))

// Skips spaces and comments
(Parser.skipper str:String) : String
  (Parser.skipper String.nil)         = String.nil
  (Parser.skipper (String.cons x xs)) = (Parser.skipper.go (Char.is_space x) (== x 47) x xs)

(Parser.skipper.go is_space:U32 is_slash:U32 x:Char xs:String): String
  (Parser.skipper.go 0 0 x xs) = (String.cons x xs)
  (Parser.skipper.go 1 c x xs) = (Parser.skipper xs)
  (Parser.skipper.go s 1 x xs) = (Parser.skipper.drop_comment xs)

(Parser.skipper.drop_comment str:String): String
  (Parser.skipper.drop_comment String.nil)         = String.nil
  (Parser.skipper.drop_comment (String.cons x xs)) = (Parser.skipper.drop_comment.go (== x 10) x xs) 

(Parser.skipper.drop_comment.go is_space:U32 x:Char xs:String): String
  (Parser.skipper.drop_comment.go 1 x xs) = (Parser.skipper xs)
  (Parser.skipper.drop_comment.go 0 x xs) = (Parser.skipper.drop_comment xs)

(Parser.parse_name_here) : (Parser String)
  (Parser.parse_name_here) = λcode (Parser.parse_name_here.go ((Parser.get_name) code))

(Parser.parse_name_here.go name:(Pair Code String)): (Answer String)
  (Parser.parse_name_here.go (Pair.new String String code name)) = (Answer.parsed String code name)

(Parser.parse_name) : (Parser String)
  (Parser.parse_name) = λcode ((Parser.parse_name_here) (Parser.skipper code))

(Parser.parse_end) : (Parser Bool)
  Parser.parse_end = λcode (Parser.parse_end.go code)
(Parser.parse_end.go code:String) : (Answer Bool)
  (Parser.parse_end.go String.nil)         = (Answer.parsed Bool String.nil Bool.true)
  (Parser.parse_end.go (String.cons x xs)) = (Answer.parsed Bool (String.cons x xs) Bool.false)

(Parser.parse_until a:Type stop:(Parser Bool) parser:(Parser a)) : (Parser (List a))
  (Parser.parse_until a stop parser) = (Parser.bind Bool (List a) stop λs (Parser.parse_until.go a s stop parser))

(Parser.parse_until.go a:Type s:Bool stop:(Parser Bool) parser:(Parser a)) : (Parser (List a))
  (Parser.parse_until.go a Bool.false stop parser) =
    (Parser.bind a        (List a) parser                             λhead 
    (Parser.bind (List a) (List a) (Parser.parse_until a stop parser) λtail 
    (Parser.done (List a) (List.cons a head tail))))
  (Parser.parse_until.go a Bool.true stop parser) =
    (Parser.done (List a) (List.nil a))

(Parser.grammar a:Type choices:(List (Parser (Maybe a))))          : (Parser a)
  (Parser.grammar a (List.nil (Parser (Maybe a))))                 = λcode (Answer.failed a "TODO: Parser.grammer empty list")
  (Parser.grammar a (List.cons (Parser (Maybe a)) choice choices)) = λcode (Parser.grammar.go a (choice code) choices)

(Parser.grammar.go a:Type choice_res:(Answer (Maybe a)) choices:(List (Parser (Maybe a)))) : (Answer a)
  (Parser.grammar.go a (Answer.failed a err)                        choices) = (Answer.failed a err)
  (Parser.grammar.go a (Answer.parsed a code (Maybe.none a))        choices) = ((Parser.grammar a choices) code)
  (Parser.grammar.go a (Answer.parsed a code (Maybe.some a result)) choices) = (Answer.parsed a code result)

// Note: unlike Rust's version, this won't rollback
(Parser.guard a:Type head:(Parser Bool) body:(Parser a)) : (Parser (Maybe a))
  (Parser.guard a head body) = λcode (Parser.guard.go a (head code) body)

(Parser.guard.go a:Type head_res:(Answer Bool) body:(Parser a)) : (Answer (Maybe a))
  (Parser.guard.go a (Answer.failed Bool err)             body) = (Answer.failed (Maybe a) err)
  (Parser.guard.go a (Answer.parsed Bool code Bool.false) body) = (Answer.parsed (Maybe a) code (Maybe.none a))
  (Parser.guard.go a (Answer.parsed Bool code Bool.true)  body) = ((Parser.bind a (Maybe a) body λgot (Parser.done _ (Maybe.some a got))) code)

// #############################################################################
// # Kind2                                                                     #
// #############################################################################


// Parsing
// -------

Op : Type 
 Op.ADD : Op
 Op.SUB : Op
 Op.MUL : Op
 Op.DIV : Op
 Op.MOD : Op
 Op.AND : Op
 Op.OR  : Op
 Op.XOR : Op
 Op.SHL : Op
 Op.SHR : Op
 Op.LTE : Op
 Op.LTN : Op
 Op.EQL : Op
 Op.GTE : Op
 Op.GTN : Op
 Op.NEQ : Op

Term : Type
  (Term.let name:Name expr:Term body:Term)           : Term
  (Term.cts name:Name list:(List Term))              : Term
  (Term.o32 op:Op val0:Term val1:Term)               : Term
  (Term.lam name:Name body:Term)                     : Term
  (Term.rfl expr:Term)                               : Term
  (Term.app f:Term x:Term)                           : Term
  (Term.var name:Name)                               : Term
  (Term.n32 value:U32)                               : Term
  (Term.u32)                                         : Term
  (Term.all name:Name type:Term body:Term)           : Term
  (Term.gol name:Name)                               : Term
  (Term.typ)                                         : Term
  (Term.ann expr:Term type:Term)                     : Term
  (Term.hol hash:Name)                               : Term     
  (Term.eql val0:Term val1:Term)                     : Term
  (Term.rwt name:Name witn:Term goal:Term expr:Term) : Term

// TODO: complete
(Parser.parse_oper) : (Parser Op)
  (Parser.parse_oper) =
    (Parser.grammar Op (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "+")  (Parser.done Op Op.ADD))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "*")  (Parser.done Op Op.MUL))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text (String.cons '/' (String.nil)))  (Parser.done Op Op.DIV))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "%")  (Parser.done Op Op.MOD))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "&")  (Parser.done Op Op.AND))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "|")  (Parser.done Op Op.OR))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "^")  (Parser.done Op Op.XOR))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "<<") (Parser.done Op Op.SHL))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text ">>") (Parser.done Op Op.SHR))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "<=") (Parser.done Op Op.LTE))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "<")  (Parser.done Op Op.LTN))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "==") (Parser.done Op Op.EQL))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text ">=") (Parser.done Op Op.GTE))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text ">")  (Parser.done Op Op.GTN))
                       (List.cons (Parser (Maybe Op)) (Parser.guard Op (Parser.match_text "!=") (Parser.done Op Op.NEQ))
                       (List.nil (Parser (Maybe Op)))))))))))))))))))

(Parser.parse_var) : (Parser (Maybe Term))
  (Parser.parse_var) = (Parser.bind String (Maybe Term) (Parser.parse_name) λname (Parser.parse_var.0 name))

(Parser.parse_var.0 name:String) : (Parser (Maybe Term))
  (Parser.parse_var.0 String.nil)   = (Parser.done _ (Maybe.none Term))
  (Parser.parse_var.0 (String.cons x xs)) = (Parser.parse_var.1
    (String.equal (String.cons x xs) "Type")
    (String.equal (String.cons x xs) "U32")
    (Char.is_upper x)
    (Char.is_numeric x)
    (String.cons x xs))

(Parser.parse_var.1 a:U32 b:U32 c:U32 d:U32 str:String) : (Parser (Maybe Term))
  (Parser.parse_var.1 1 b c d str) = (Parser.done (Maybe Term) (Maybe.some Term Term.typ))
  (Parser.parse_var.1 a 1 c d str) = (Parser.done (Maybe Term) (Maybe.some Term Term.u32))
  (Parser.parse_var.1 a b 1 d str) = (Parser.done (Maybe Term) (Maybe.some Term (Term.cts (Name.make str) (List.nil Term))))
  (Parser.parse_var.1 a b c 1 str) = (Parser.done (Maybe Term) (Maybe.some Term (Term.n32 (U32.read str))))
  (Parser.parse_var.1 a b c d str) =
    (Parser.bind Bool (Maybe Term) (Parser.match_text ":") (λis_ann (Parser.parse_var.2 (Bool.if U32 is_ann 1 0) str)))

(Parser.parse_var.2 i:U32 str:String) : (Parser (Maybe Term))
  (Parser.parse_var.2 0 str) = (Parser.done (Maybe Term) (Maybe.some Term (Term.var (Name.make str))))
  (Parser.parse_var.2 1 str) =
    (Parser.bind Term (Maybe Term) Parser.parse_term λterm (Parser.done (Maybe Term) (Maybe.some Term (Term.ann (Term.var (Name.make str)) term))))

(Parser.parse_let) : (Parser (Maybe Term))
(Parser.parse_let) = (Parser.guard Term (Parser.match_text "let")
  (Parser.bind String Term (Parser.parse_name)            λname
  (Parser.bind Bool Term (Parser.match_text ":")   λanns
  (Parser.parse_let_ann anns name))))

(Parser.parse_let_ann b:Bool name:String) : (Parser Term)
  (Parser.parse_let_ann Bool.true name) =
    (Parser.bind Term Term Parser.parse_term            λtype
    (Parser.bind Unit Term (Parser.parse_text "=") λskip
    (Parser.bind Term Term Parser.parse_term            λexpr
    (Parser.bind Term Term Parser.parse_term            λbody
    (Parser.done Term (Term.let (Name.make name) (Term.ann expr type) body))))))
  (Parser.parse_let_ann Bool.false name) =
    (Parser.bind Unit Term (Parser.parse_text "=") λskip
    (Parser.bind Term Term Parser.parse_term            λexpr
    (Parser.bind Term Term Parser.parse_term            λbody
    (Parser.done Term (Term.let (Name.make name) expr body)))))

(Parser.parse_def) : (Parser (Maybe Term))
(Parser.parse_def) = (Parser.guard Term (Parser.match_text "def")
  (Parser.bind String Term (Parser.parse_name)          λname
  (Parser.bind Bool Term (Parser.match_text ":") λanns
  (Parser.parse_def_ann anns name))))

(Parser.parse_def_ann b:Bool name:String) : (Parser Term)
  (Parser.parse_def_ann Bool.true name) =
    (Parser.bind Term Term Parser.parse_term            λtype
    (Parser.bind Unit Term (Parser.parse_text "=") λskip
    (Parser.bind Term Term Parser.parse_term            λexpr
    (Parser.bind Term Term Parser.parse_term            λbody
    (Parser.done Term (Term.def (Name.make name) (Term.ann expr type) body))))))
  (Parser.parse_def_ann Bool.false name) =
    (Parser.bind Unit Term (Parser.parse_text "=") λskip
    (Parser.bind Term Term Parser.parse_term            λexpr
    (Parser.bind Term Term Parser.parse_term            λbody
    (Parser.done Term (Term.def (Name.make name) expr body)))))

(Parser.parse_hol) : (Parser (Maybe Term))
(Parser.parse_hol) = (Parser.guard Term (Parser.match_text "_")
  (Parser.bind String Term (Parser.parse_name) λname
  (Parser.done Term (Term.hol (Name.make name)))))

(Parser.parse_gol) : (Parser (Maybe Term))
(Parser.parse_gol) = (Parser.guard Term (Parser.match_text "?")
  (Parser.bind String Term (Parser.parse_name) λname
  (Parser.done Term (Term.gol (Name.make name)))))

(Parser.parse_lam) : (Parser (Maybe Term))
(Parser.parse_lam) = (Parser.guard Term (Parser.match_text "λ")
  (Parser.bind String Term (Parser.parse_name) λname
  (Parser.bind Term Term (Parser.parse_term)   λbody
  (Parser.done Term (Term.lam (Name.make name) body)))))

(Parser.parse_all) : (Parser (Maybe Term))
(Parser.parse_all) = (Parser.guard Term (Parser.match_text "∀")
  (Parser.bind Unit Term (Parser.parse_text "(") λskip
  (Parser.bind String Term (Parser.parse_name)           λname
  (Parser.bind Unit Term (Parser.parse_text ":")  λskip
  (Parser.bind Term Term (Parser.parse_term)             λtype
  (Parser.bind Unit Term (Parser.parse_text ")") λskip
  (Parser.bind Term Term (Parser.parse_term)             λbody
  (Parser.done Term (Term.all (Name.make name) type body)))))))))

(Parser.parse_rwt) : (Parser (Maybe Term))
(Parser.parse_rwt) = (Parser.guard Term (Parser.match_text "rewrite")
  (Parser.bind String Term (Parser.parse_name)         λname
  (Parser.bind Unit Term (Parser.parse_text "with") λskip
  (Parser.bind Term Term (Parser.parse_term)           λwitn
  (Parser.bind Unit Term (Parser.parse_text "with") λskip
  (Parser.bind Term Term (Parser.parse_term)           λgoal
  (Parser.bind Term Term (Parser.parse_term)           λexpr
  (Parser.done Term (Term.rwt (Name.make name) witn goal expr)))))))))

(Parser.parse_rfl) : (Parser (Maybe Term))
(Parser.parse_rfl) = (Parser.guard Term (Parser.match_text "refl")
  (Parser.bind Term Term (Parser.parse_term) λexpr
  (Parser.done Term (Term.rfl expr))))

(Parser.parse_chr) : (Parser (Maybe Term))
(Parser.parse_chr) = (Parser.guard Term (Parser.match_text "'")
  (Parser.bind U32 Term (Parser.parse_one)             λchr
  (Parser.bind Unit Term (Parser.parse_text "with") λskip
  (Parser.done Term (Term.n32 chr)))))

(Parser.parse_o32) : (Parser (Maybe Term))
  (Parser.parse_o32) = (Parser.guard Term (Parser.peek_conds (List.cons ∀(x:Char)U32 λx(== x '(')
                                                             (List.cons ∀(x:Char)U32 λx(Parser.is_operator x)
                                                             (List.nil  ∀(x:Char)U32))))
    (Parser.bind Unit Term (Parser.parse_text "(") λskip
    (Parser.bind Op Term (Parser.parse_oper)               λoper
    (Parser.bind Term Term (Parser.parse_term)             λval0
    (Parser.bind Term Term (Parser.parse_term)             λval1
    (Parser.bind Unit Term (Parser.parse_text ")") λskip
    (Parser.done Term (Term.o32 oper val0 val1))))))))

(Parser.parse_cts) : (Parser (Maybe Term))
  (Parser.parse_cts) = (Parser.guard Term (Parser.peek_conds (List.cons ∀(x:Char)U32 λx(== x '(')
                                                             (List.cons ∀(x:Char)U32 λx(Char.is_upper x)
                                                             (List.nil  ∀(x:Char)U32))))
    (Parser.bind Unit Term (Parser.parse_text "(")                                                    λskip
    (Parser.bind String Term (Parser.parse_name)                                                              λname
    (Parser.bind (List Term) Term (Parser.parse_until Term (Parser.match_text ")") Parser.parse_term) λargs
    (Parser.done Term (Term.cts (Name.make name) args))))))

(Parser.parse_ann_eql) : (Parser (Maybe Term))
(Parser.parse_ann_eql) = (Parser.guard Term (Parser.match_text "(")
  (Parser.bind Term Term (Parser.parse_term)             λval0
  (Parser.bind Bool Term (Parser.match_text "::") λanns
  (Parser.parse_ann_eql_go anns val0))))

(Parser.parse_ann_eql_go b:Bool val0:Term) : (Parser Term)
  (Parser.parse_ann_eql_go Bool.true val0) =
    (Parser.bind Term Term (Parser.parse_term)             λval1
    (Parser.bind Unit Term (Parser.parse_text ")") λskip
    (Parser.done Term (Term.ann val0 val1))))
  (Parser.parse_ann_eql_go Bool.false val0) =
    (Parser.bind Unit Term (Parser.parse_text "==") λskip
    (Parser.bind Term Term (Parser.parse_term)             λval1
    (Parser.bind Unit Term (Parser.parse_text ")") λskip
    (Parser.done Term (Term.eql val0 val1)))))

(Parser.parse_app) : (Parser (Maybe Term))
(Parser.parse_app) = (Parser.guard Term (Parser.match_text "(")
  (Parser.bind Term Term (Parser.parse_term)                                                                λfunc
  (Parser.bind (List Term) Term (Parser.parse_until Term (Parser.match_text ")") Parser.parse_term) λargs
  (Parser.done Term ((List.fold Term ∀(a:Term)Term args λx(x) λxλtλf(t (Term.app f x))) func)))))

// (Parser.parse_str) : (Parser (Maybe Term))
// (Parser.parse_str) = (Parser.guard Term (Parser.match_text "'")
//   (Parser.bind (List Term) Term (Parser.parse_until Term (Parser.match_text "'") Parser.parse_one) λchars
//   (Parser.done Term (Parser.parse_str_make chars))))

// (Parser.parse_str_make (List Term)) : Term
// (Parser.parse_str_make (List.cons x xs) = (Term.cts (Name.make String.cons) (List.cons (N32 x) (Parser.parse_str_make xs))))
// (Parser.parse_str_make List.nil) = (Term.cts (Name.make String.nil) List.nil)

// FIXME: or better INFER ME
(Parser.parse_term) : (Parser Term)
//   (Parser.parse_term) =
//     (Parser.bind Term Term ((Parser.parse_term.ini) λini
//     (Parser.bind ∀(x:Term)Term Term ((Parser.parse_term.end) λend
//     (Parser.done Term (end ini))))))

(Parser.parse_term.ini) : (Parser Term)
(Parser.parse_term.ini) =
  (Parser.grammar Term (List.cons (Parser (Maybe Term)) Parser.parse_def
                       (List.cons (Parser (Maybe Term)) Parser.parse_let
                       (List.cons (Parser (Maybe Term)) Parser.parse_cts
                       (List.cons (Parser (Maybe Term)) Parser.parse_o32
                       (List.cons (Parser (Maybe Term)) Parser.parse_all
                       (List.cons (Parser (Maybe Term)) Parser.parse_lam
                       (List.cons (Parser (Maybe Term)) Parser.parse_app
                       (List.cons (Parser (Maybe Term)) Parser.parse_chr
                       // (List.cons (Parser (Maybe Term)) Parser.parse_str
                       (List.cons (Parser (Maybe Term)) Parser.parse_gol
                       (List.cons (Parser (Maybe Term)) Parser.parse_rfl
                       (List.cons (Parser (Maybe Term)) Parser.parse_rwt
                       (List.cons (Parser (Maybe Term)) Parser.parse_ann_eql
                       (List.cons (Parser (Maybe Term)) Parser.parse_hol
                       (List.cons (Parser (Maybe Term)) Parser.parse_var
                       (List.nil  (Parser (Maybe Term))))))))))))))))))

(Parser.parse_term.end) : (Parser ∀(x:Term)Term)
(Parser.parse_term.end) =
  let xs = (List.cons (Parser (Maybe ∀(x:Term)Term)) (Parser.done (Maybe ∀(x:Term)Term) (Maybe.some ∀(x:Term)Term λx(x))) 
           (List.nil (Parser (Maybe ∀(x:Term)Term))))

  (Parser.grammar ∀(x:Term)Term xs)

(Term.def Name Term Term) : Term
(Term.def nm val (Term.var name))                = (U32.if Term (Name.equal name nm) val (Term.var name))
(Term.def nm val (Term.hol hash))                = (Term.hol hash)
(Term.def nm val Term.typ)                       = Term.typ
(Term.def nm val Term.u32)                       = Term.u32
(Term.def nm val (Term.n32 numb))                = (Term.n32 numb)
(Term.def nm val (Term.o32 oper val0 val1))      = (Term.o32 oper (Term.def nm val val0) (Term.def nm val val1))
(Term.def nm val (Term.gol name))                = (Term.gol name)
(Term.def nm val (Term.ann xval xtyp))           = (Term.ann (Term.def nm val xval) (Term.def nm val xtyp))
(Term.def nm val (Term.let name expr body))      = (Term.let name (Term.def nm val expr) (Term.def.body nm val name body))
(Term.def nm val (Term.all name type body))      = (Term.all name (Term.def nm val type) (Term.def.body nm val name body))
(Term.def nm val (Term.lam name body))           = (Term.lam name (Term.def.body nm val name body))
(Term.def nm val (Term.app func argm))           = (Term.app (Term.def nm val func) (Term.def nm val argm))
(Term.def nm val (Term.cts ctid args))           = (Term.cts ctid (Term.def.many nm val args))
(Term.def nm val (Term.eql val0 val1))           = (Term.eql (Term.def nm val val0) (Term.def nm val val1))
(Term.def nm val (Term.rfl expr))                = (Term.rfl (Term.def nm val expr))
(Term.def nm val (Term.rwt name witn goal expr)) = (Term.rwt name (Term.def nm val witn) (Term.def.body nm val name goal) (Term.def nm val expr))

(Term.def.many nm:Name val:Term list:(List Term)) : (List Term)
  (Term.def.many nm val (List.nil Term))      = (List.nil Term)
  (Term.def.many nm val (List.cons Term x xs)) = (List.cons Term (Term.def nm val x) (Term.def.many nm val xs))

(Term.def.body nm:Name val:Term name:Name body:Term) : Term
  (Term.def.body nm val name body) = (Term.def.body.go (Name.equal nm name) nm val body)

(Term.def.body.go i:U32 nm:Name val:Term body:Term) : Term
  (Term.def.body.go 0 nm val body) = (Term.def nm val body)
  (Term.def.body.go 1 nm val body) = body
  
// Utils
// =====

(Utils.get_id term:Term) : Name
  (Utils.get_id (Term.cts ctid args)) = ctid
  (Utils.get_id term)                 = (Name.make "?")

(Utils.var_get_name term:Term) : Name
  (Utils.var_get_name (Term.var name)) = name
  (Utils.var_get_name x) = (Name.make "_")

(Utils.arg_get term:Term cont:∀(x:Name)∀(y:Term)Term) : Term
  (Utils.arg_get (Term.ann var expr) cont) = (cont (Utils.var_get_name var) expr)
  (Utils.arg_get term                cont) = (cont (Name.make "_") term)

